<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>sym-ildl: lilc_matrix&lt; el_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">sym-ildl
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Incomplete LDL&#39; factorizations of indefinite symmetric matrices.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classlilc__matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lilc_matrix&lt; el_type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A list-of-lists (LIL) matrix in column oriented format.  
 <a href="classlilc__matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lilc__matrix_8h_source.html">lilc_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lilc_matrix&lt; el_type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix__inherit__graph.png" border="0" usemap="#lilc__matrix_3_01el__type_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="lilc__matrix_3_01el__type_01_4_inherit__map" id="lilc__matrix_3_01el__type_01_4_inherit__map">
<area shape="rect" id="node2" href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices. " alt="" coords="13,5,152,47"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for lilc_matrix&lt; el_type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix__coll__graph.png" border="0" usemap="#lilc__matrix_3_01el__type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="lilc__matrix_3_01el__type_01_4_coll__map" id="lilc__matrix_3_01el__type_01_4_coll__map">
<area shape="rect" id="node2" href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices. " alt="" coords="181,109,320,151"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c53c4a5816e0e21a167044f07b2ba6a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6a">pivot_type</a> { <a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">pivot_type::BKP</a>, 
<a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aa97c60a3a4e61ee21e3f38a2f950fe293">pivot_type::ROOK</a>
 }</td></tr>
<tr class="separator:a9c53c4a5816e0e21a167044f07b2ba6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c70482c28275881562ee3937b5f591"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a>&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">idx_vector_type</a></td></tr>
<tr class="separator:a83c70482c28275881562ee3937b5f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a7b6e31a6c9ebf2ea3a898fe646af6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a>&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">elt_vector_type</a></td></tr>
<tr class="separator:aa5a7b6e31a6c9ebf2ea3a898fe646af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd399b5bc0ef50dcf5a59a671e32248"><td class="memItemLeft" align="right" valign="top">typedef idx_vector_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a></td></tr>
<tr class="separator:a8cd399b5bc0ef50dcf5a59a671e32248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34c37b7095e283a7e5d7160fe26fd1b"><td class="memItemLeft" align="right" valign="top">typedef elt_vector_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a></td></tr>
<tr class="separator:ad34c37b7095e283a7e5d7160fe26fd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classlil__sparse__matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classlil__sparse__matrix')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix&lt; el_type &gt;</a></td></tr>
<tr class="memitem:aac6d12fd87c19ad7d39f0fbdf7e0aa01 inherit pub_types_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a></td></tr>
<tr class="separator:aac6d12fd87c19ad7d39f0fbdf7e0aa01 inherit pub_types_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac442ebc44706f184c7ce4ee7e1fdd6d inherit pub_types_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; el_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a></td></tr>
<tr class="separator:aac442ebc44706f184c7ce4ee7e1fdd6d inherit pub_types_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdaad0931ff27d7bfc361d3033713914"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#acdaad0931ff27d7bfc361d3033713914">lilc_matrix</a> (int <a class="el" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>=0, int <a class="el" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>=0)</td></tr>
<tr class="memdesc:acdaad0931ff27d7bfc361d3033713914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a column oriented list-of-lists (LIL) matrix. Space for both the values list and the indices list of the matrix is allocated here.  <a href="#acdaad0931ff27d7bfc361d3033713914">More...</a><br /></td></tr>
<tr class="separator:acdaad0931ff27d7bfc361d3033713914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e59d373ec514c8cb264da653d36f753"><td class="memItemLeft" align="right" valign="top">virtual el_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a> (const int &amp;i, const int &amp;j, int offset=0) const </td></tr>
<tr class="memdesc:a0e59d373ec514c8cb264da653d36f753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the (i,j)th coefficient of the matrix.  <a href="#a0e59d373ec514c8cb264da653d36f753">More...</a><br /></td></tr>
<tr class="separator:a0e59d373ec514c8cb264da653d36f753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c165f0c90cd362dd14fc6421ebadd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">coeffRef</a> (const int &amp;i, const int &amp;j, std::pair&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a>, <a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> &gt; &amp;its)</td></tr>
<tr class="memdesc:a327c165f0c90cd362dd14fc6421ebadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index/value pointers to (i,j)th coefficient of the matrix.  <a href="#a327c165f0c90cd362dd14fc6421ebadd">More...</a><br /></td></tr>
<tr class="separator:a327c165f0c90cd362dd14fc6421ebadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca815e0ac073abb1e6ef888b09f9e795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">resize</a> (int <a class="el" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, int <a class="el" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>)</td></tr>
<tr class="memdesc:aca815e0ac073abb1e6ef888b09f9e795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix. For use in preallocating space before factorization begins.  <a href="#aca815e0ac073abb1e6ef888b09f9e795">More...</a><br /></td></tr>
<tr class="separator:aca815e0ac073abb1e6ef888b09f9e795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46161695c5bfb0f43a7dedb9b9146fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a46161695c5bfb0f43a7dedb9b9146fef">find_root</a> (int &amp;s)</td></tr>
<tr class="memdesc:a46161695c5bfb0f43a7dedb9b9146fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pseudo-peripheral root of A. This is essentially many chained breadth-first searchs across the graph of A (where A is viewed as an adjacency matrix).  <a href="#a46161695c5bfb0f43a7dedb9b9146fef">More...</a><br /></td></tr>
<tr class="separator:a46161695c5bfb0f43a7dedb9b9146fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad343cd9b2f435f40a9866de050f63ce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5">find_level_set</a> (vector&lt; int &gt; &amp;lvl_set, vector&lt; bool &gt; &amp;visited)</td></tr>
<tr class="memdesc:ad343cd9b2f435f40a9866de050f63ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next level set given the current level set of A. This is essentially all neighbours of the currently enqueued nodes in breath-first search.  <a href="#ad343cd9b2f435f40a9866de050f63ce5">More...</a><br /></td></tr>
<tr class="separator:ad343cd9b2f435f40a9866de050f63ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34914d2b48a5bf14e7ef22e89d2f2e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ab34914d2b48a5bf14e7ef22e89d2f2e7">sym_rcm</a> (vector&lt; int &gt; &amp;perm)</td></tr>
<tr class="memdesc:ab34914d2b48a5bf14e7ef22e89d2f2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Reverse Cuthill-McKee ordering of the matrix A (stored in perm).  <a href="#ab34914d2b48a5bf14e7ef22e89d2f2e7">More...</a><br /></td></tr>
<tr class="separator:ab34914d2b48a5bf14e7ef22e89d2f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add59bf538bd6b36c7d42ec879bad4da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#add59bf538bd6b36c7d42ec879bad4da8">sym_amd</a> (vector&lt; int &gt; &amp;perm)</td></tr>
<tr class="memdesc:add59bf538bd6b36c7d42ec879bad4da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Approximate Minimum Degree ordering of the matrix A (stored in perm).  <a href="#add59bf538bd6b36c7d42ec879bad4da8">More...</a><br /></td></tr>
<tr class="separator:add59bf538bd6b36c7d42ec879bad4da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72f55f6880cef04205eb3df7018bce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#af72f55f6880cef04205eb3df7018bce9">sym_perm</a> (vector&lt; int &gt; &amp;perm)</td></tr>
<tr class="memdesc:af72f55f6880cef04205eb3df7018bce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a permutation vector perm, A is permuted to P'AP, where P is the permutation matrix associated with perm.  <a href="#af72f55f6880cef04205eb3df7018bce9">More...</a><br /></td></tr>
<tr class="separator:af72f55f6880cef04205eb3df7018bce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fc8dcc40799dfde0decaaf8bd74b51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a37fc8dcc40799dfde0decaaf8bd74b51">sym_equil</a> ()</td></tr>
<tr class="memdesc:a37fc8dcc40799dfde0decaaf8bd74b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A, where S is a diagonal scaling matrix.  <a href="#a37fc8dcc40799dfde0decaaf8bd74b51">More...</a><br /></td></tr>
<tr class="separator:a37fc8dcc40799dfde0decaaf8bd74b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e027b8d354b29b8fcd9a7777835dc3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a1e027b8d354b29b8fcd9a7777835dc3f">ildl</a> (<a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;L, <a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;D, <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;perm, const double &amp;fill_factor, const double &amp;tol, const double &amp;pp_tol, <a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6a">pivot_type</a> piv_type=<a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">pivot_type::BKP</a>)</td></tr>
<tr class="memdesc:a1e027b8d354b29b8fcd9a7777835dc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an LDL' factorization of this matrix.  <a href="#a1e027b8d354b29b8fcd9a7777835dc3f">More...</a><br /></td></tr>
<tr class="separator:a1e027b8d354b29b8fcd9a7777835dc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc83364ccef8d296e7dabed833d865c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a8cc83364ccef8d296e7dabed833d865c">ildl_inplace</a> (<a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;D, <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;perm, const double &amp;fill_factor, const double &amp;tol, const double &amp;pp_tol, <a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6a">pivot_type</a> piv_type=<a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">pivot_type::BKP</a>)</td></tr>
<tr class="memdesc:a8cc83364ccef8d296e7dabed833d865c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an <em>inplace</em> LDL' factorization of this matrix.  <a href="#a8cc83364ccef8d296e7dabed833d865c">More...</a><br /></td></tr>
<tr class="separator:a8cc83364ccef8d296e7dabed833d865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0dbfcd1cda4ab3bc067b16f17f7f2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a9e0dbfcd1cda4ab3bc067b16f17f7f2f">backsolve</a> (const <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;b, <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;x)</td></tr>
<tr class="memdesc:a9e0dbfcd1cda4ab3bc067b16f17f7f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a back solve of this matrix, assuming that it is lower triangular (stored column major).  <a href="#a9e0dbfcd1cda4ab3bc067b16f17f7f2f">More...</a><br /></td></tr>
<tr class="separator:a9e0dbfcd1cda4ab3bc067b16f17f7f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd669063a9594f4d33b01f24bf693edd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#afd669063a9594f4d33b01f24bf693edd">forwardsolve</a> (const <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;b, <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;x)</td></tr>
<tr class="memdesc:afd669063a9594f4d33b01f24bf693edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a forward solve of this matrix, assuming that it is upper triangular (stored row major).  <a href="#afd669063a9594f4d33b01f24bf693edd">More...</a><br /></td></tr>
<tr class="separator:afd669063a9594f4d33b01f24bf693edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00362a639b1e8ec341014c39afaf5e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a00362a639b1e8ec341014c39afaf5e5a">multiply</a> (const <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;x, <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;y, bool full_mult=true)</td></tr>
<tr class="memdesc:a00362a639b1e8ec341014c39afaf5e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a matrix-vector product with this matrix.  <a href="#a00362a639b1e8ec341014c39afaf5e5a">More...</a><br /></td></tr>
<tr class="separator:a00362a639b1e8ec341014c39afaf5e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c9a672941d6b47d3c60f631d21078c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c">pivot</a> (<a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt; s, vector&lt; bool &gt; &amp;in_set, <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;L, const int &amp;k, const int &amp;r)</td></tr>
<tr class="memdesc:ad2c9a672941d6b47d3c60f631d21078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symmetric permutation between row/col k &amp; r of A.  <a href="#ad2c9a672941d6b47d3c60f631d21078c">More...</a><br /></td></tr>
<tr class="separator:ad2c9a672941d6b47d3c60f631d21078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4cb5093a935dd9411839c8f54c5a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">pivotA</a> (<a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt; s, vector&lt; bool &gt; &amp;in_set, const int &amp;k, const int &amp;r)</td></tr>
<tr class="memdesc:a5a4cb5093a935dd9411839c8f54c5a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inplace version of the function above.  <a href="#a5a4cb5093a935dd9411839c8f54c5a7b">More...</a><br /></td></tr>
<tr class="separator:a5a4cb5093a935dd9411839c8f54c5a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d3045545357a8f33955a87dc55f3aa"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:aa1d3045545357a8f33955a87dc55f3aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a> (const int &amp;j, const int &amp;k, Container &amp;con, bool update_list=false)</td></tr>
<tr class="memdesc:aa1d3045545357a8f33955a87dc55f3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures two the invariants observed by A.first and A.list are held.  <a href="#aa1d3045545357a8f33955a87dc55f3aa">More...</a><br /></td></tr>
<tr class="separator:aa1d3045545357a8f33955a87dc55f3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177dde39764c88fe4e82b050a5e60303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a> (const int &amp;k)</td></tr>
<tr class="memdesc:a177dde39764c88fe4e82b050a5e60303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates A.first for iteration k.  <a href="#a177dde39764c88fe4e82b050a5e60303">More...</a><br /></td></tr>
<tr class="separator:a177dde39764c88fe4e82b050a5e60303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ee09328b84657630f52631ea8e5eb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a> (const int &amp;k)</td></tr>
<tr class="memdesc:ab9ee09328b84657630f52631ea8e5eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates A.list for iteration k.  <a href="#ab9ee09328b84657630f52631ea8e5eb1">More...</a><br /></td></tr>
<tr class="separator:ab9ee09328b84657630f52631ea8e5eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c5a4a0ec9a49d43be087b6d67f4df2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a60c5a4a0ec9a49d43be087b6d67f4df2">to_string</a> () const </td></tr>
<tr class="memdesc:a60c5a4a0ec9a49d43be087b6d67f4df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of A, with each column and its corresponding indices &amp; non-zero values printed.  <a href="#a60c5a4a0ec9a49d43be087b6d67f4df2">More...</a><br /></td></tr>
<tr class="separator:a60c5a4a0ec9a49d43be087b6d67f4df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5613e9a57231a6991dcf99d6d7b37a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aea5613e9a57231a6991dcf99d6d7b37a">load</a> (std::string filename)</td></tr>
<tr class="memdesc:aea5613e9a57231a6991dcf99d6d7b37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a matrix in matrix market format.  <a href="#aea5613e9a57231a6991dcf99d6d7b37a">More...</a><br /></td></tr>
<tr class="separator:aea5613e9a57231a6991dcf99d6d7b37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0161d36019e1abac41b6119b8fa288"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a2b0161d36019e1abac41b6119b8fa288">save</a> (std::string filename, bool sym=false)</td></tr>
<tr class="memdesc:a2b0161d36019e1abac41b6119b8fa288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a matrix in matrix market format.  <a href="#a2b0161d36019e1abac41b6119b8fa288">More...</a><br /></td></tr>
<tr class="separator:a2b0161d36019e1abac41b6119b8fa288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlil__sparse__matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlil__sparse__matrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix&lt; el_type &gt;</a></td></tr>
<tr class="memitem:a74dff1c9df79556341d714d4530ffe38 inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a74dff1c9df79556341d714d4530ffe38">lil_sparse_matrix</a> (int <a class="el" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, int <a class="el" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>)</td></tr>
<tr class="memdesc:a74dff1c9df79556341d714d4530ffe38 inherit pub_methods_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for an abstract matrix. This constructor will be extended by base classes depending on the representation of the matrix (LIL-C or LIL-R).  <a href="#a74dff1c9df79556341d714d4530ffe38">More...</a><br /></td></tr>
<tr class="separator:a74dff1c9df79556341d714d4530ffe38 inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e9ea5f7c8a9fca9029a91b39c592e0 inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a> () const </td></tr>
<tr class="separator:a29e9ea5f7c8a9fca9029a91b39c592e0 inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88631204bcf7c9a223fb082a7d0cd3d inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a> () const </td></tr>
<tr class="separator:ac88631204bcf7c9a223fb082a7d0cd3d inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bc09d3b6716e57134eed0aeba49199 inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a> () const </td></tr>
<tr class="separator:a40bc09d3b6716e57134eed0aeba49199 inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd4e61eeb73f709d0900cc064d8986d inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#aebd4e61eeb73f709d0900cc064d8986d">~lil_sparse_matrix</a> ()</td></tr>
<tr class="separator:aebd4e61eeb73f709d0900cc064d8986d inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad942a0e5503a2b4327a12287432fca81"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a></td></tr>
<tr class="memdesc:ad942a0e5503a2b4327a12287432fca81"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may swap between two rows, we require linked lists for each row of A.  <a href="#ad942a0e5503a2b4327a12287432fca81">More...</a><br /></td></tr>
<tr class="separator:ad942a0e5503a2b4327a12287432fca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca57e0c3866ed0cf1f17f6253666ebb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a></td></tr>
<tr class="memdesc:a2ca57e0c3866ed0cf1f17f6253666ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i, k).  <a href="#a2ca57e0c3866ed0cf1f17f6253666ebb">More...</a><br /></td></tr>
<tr class="separator:a2ca57e0c3866ed0cf1f17f6253666ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c12de6fccae4ac5a885e8aa60788e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a></td></tr>
<tr class="memdesc:a36c12de6fccae4ac5a885e8aa60788e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i, k).  <a href="#a36c12de6fccae4ac5a885e8aa60788e9">More...</a><br /></td></tr>
<tr class="separator:a36c12de6fccae4ac5a885e8aa60788e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4659265addfeab376ffaa8f54ed596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a></td></tr>
<tr class="memdesc:afc4659265addfeab376ffaa8f54ed596"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the <a class="el" href="classlilc__matrix.html#a37fc8dcc40799dfde0decaaf8bd74b51" title="The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A...">sym_equil()</a> function, after which SAS will be stored in place of A.  <a href="#afc4659265addfeab376ffaa8f54ed596">More...</a><br /></td></tr>
<tr class="separator:afc4659265addfeab376ffaa8f54ed596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classlil__sparse__matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classlil__sparse__matrix')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix&lt; el_type &gt;</a></td></tr>
<tr class="memitem:a6eac075dab519f837ae660c9ef933eb9 inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9">m_n_rows</a></td></tr>
<tr class="memdesc:a6eac075dab519f837ae660c9ef933eb9 inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows in the matrix.  <a href="#a6eac075dab519f837ae660c9ef933eb9">More...</a><br /></td></tr>
<tr class="separator:a6eac075dab519f837ae660c9ef933eb9 inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab335a46ece471fd0edf52540e24225a inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a></td></tr>
<tr class="memdesc:aab335a46ece471fd0edf52540e24225a inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cols in the matrix.  <a href="#aab335a46ece471fd0edf52540e24225a">More...</a><br /></td></tr>
<tr class="separator:aab335a46ece471fd0edf52540e24225a inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc8477f4f3893490bbf0b196438fab8 inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">nnz_count</a></td></tr>
<tr class="memdesc:acdc8477f4f3893490bbf0b196438fab8 inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nonzeros in the matrix.  <a href="#acdc8477f4f3893490bbf0b196438fab8">More...</a><br /></td></tr>
<tr class="separator:acdc8477f4f3893490bbf0b196438fab8 inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af764d0312eb9f7939ab144b12972bf56 inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">el_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a></td></tr>
<tr class="memdesc:af764d0312eb9f7939ab144b12972bf56 inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machine epsilon for el_type.  <a href="#af764d0312eb9f7939ab144b12972bf56">More...</a><br /></td></tr>
<tr class="separator:af764d0312eb9f7939ab144b12972bf56 inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133b6db4ddc63626a8787abbb2564aa6 inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a></td></tr>
<tr class="memdesc:a133b6db4ddc63626a8787abbb2564aa6 inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R.  <a href="#a133b6db4ddc63626a8787abbb2564aa6">More...</a><br /></td></tr>
<tr class="separator:a133b6db4ddc63626a8787abbb2564aa6 inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2abac5da68172e1e3e21376247643de inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a></td></tr>
<tr class="memdesc:ac2abac5da68172e1e3e21376247643de inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">The values of the nonzeros in the matrix.  <a href="#ac2abac5da68172e1e3e21376247643de">More...</a><br /></td></tr>
<tr class="separator:ac2abac5da68172e1e3e21376247643de inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class el_type&gt;<br />
class lilc_matrix&lt; el_type &gt;</h3>

<p>A list-of-lists (LIL) matrix in column oriented format. </p>
<p>For convience, the matrix this class represents will be refered to as matrix A. In LIL-C format, each column of A (an n*n matrix) is stored as a separate vector. The nonzeros are stored in m_idx while the non-zeros are stored in m_x. Both m_x and m_idx are initialized to a list of n lists. m_idx and m_x are ordered dependent on each other, in that A(m_idx[k][j], k) = m_x[k][j]. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad34c37b7095e283a7e5d7160fe26fd1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef elt_vector_type::iterator <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5a7b6e31a6c9ebf2ea3a898fe646af6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a>&lt;el_type&gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8cd399b5bc0ef50dcf5a59a671e32248"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef idx_vector_type::iterator <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83c70482c28275881562ee3937b5f591"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a>&lt;el_type&gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a9c53c4a5816e0e21a167044f07b2ba6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6a">lilc_matrix::pivot_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b"></a>BKP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9c53c4a5816e0e21a167044f07b2ba6aa97c60a3a4e61ee21e3f38a2f950fe293"></a>ROOK&#160;</td><td class="fielddoc">
</td></tr>
</table>
<div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                          {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        BKP, </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        ROOK</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    };</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acdaad0931ff27d7bfc361d3033713914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html">lilc_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a column oriented list-of-lists (LIL) matrix. Space for both the values list and the indices list of the matrix is allocated here. </p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                                                    : </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <a class="code" href="classlil__sparse__matrix.html">lil_sparse_matrix&lt;el_type&gt;</a> (<a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>) </div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        {</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>.reserve(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>.reserve(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a29e9ea5f7c8a9fca9029a91b39c592e0"><div class="ttname"><a href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">lil_sparse_matrix::n_rows</a></div><div class="ttdeci">int n_rows() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:46</div></div>
<div class="ttc" id="classlil__sparse__matrix_html"><div class="ttname"><a href="classlil__sparse__matrix.html">lil_sparse_matrix</a></div><div class="ttdoc">The abstract parent of all sparse matrices. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:15</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac88631204bcf7c9a223fb082a7d0cd3d"><div class="ttname"><a href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">lil_sparse_matrix::n_cols</a></div><div class="ttdeci">int n_cols() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:52</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph.png" border="0" usemap="#classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph" alt=""/></div>
<map name="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph" id="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph">
<area shape="rect" id="node2" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d" title="lil_sparse_matrix::\ln_cols" alt="" coords="208,5,344,47"/></map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a177dde39764c88fe4e82b050a5e60303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::advance_first </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates A.first for iteration k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>current iteration index. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                                                {</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].end(); it++) {  </div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                        <a class="code" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a>(*it, k, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it]); <span class="comment">//make sure next element is good before we increment.</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                        <a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>[*it]++; <span class="comment">//should have ensured invariant now</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                }</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classlilc__matrix_html_a36c12de6fccae4ac5a885e8aa60788e9"><div class="ttname"><a href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">lilc_matrix::col_first</a></div><div class="ttdeci">std::vector&lt; int &gt; col_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:47</div></div>
<div class="ttc" id="classlilc__matrix_html_aa1d3045545357a8f33955a87dc55f3aa"><div class="ttname"><a href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">lilc_matrix::ensure_invariant</a></div><div class="ttdeci">void ensure_invariant(const int &amp;j, const int &amp;k, Container &amp;con, bool update_list=false)</div><div class="ttdoc">Ensures two the invariants observed by A.first and A.list are held. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:285</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph.png" border="0" usemap="#classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph" alt=""/></div>
<map name="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph" id="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph">
<area shape="rect" id="node2" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa" title="Ensures two the invariants observed by A.first and A.list are held. " alt="" coords="200,5,336,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab9ee09328b84657630f52631ea8e5eb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::advance_list </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates A.list for iteration k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>current iteration index. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                                               {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].begin(); it != <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].end(); it++) {</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            <span class="keywordflow">if</span> (*it == k) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                        <a class="code" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a>(*it, k, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it], <span class="keyword">true</span>); <span class="comment">//make sure next element is good.</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;            <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[*it]++; <span class="comment">//invariant ensured.</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                }                       </div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlilc__matrix_html_a2ca57e0c3866ed0cf1f17f6253666ebb"><div class="ttname"><a href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">lilc_matrix::row_first</a></div><div class="ttdeci">std::vector&lt; int &gt; row_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:46</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classlilc__matrix_html_aa1d3045545357a8f33955a87dc55f3aa"><div class="ttname"><a href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">lilc_matrix::ensure_invariant</a></div><div class="ttdeci">void ensure_invariant(const int &amp;j, const int &amp;k, Container &amp;con, bool update_list=false)</div><div class="ttdoc">Ensures two the invariants observed by A.first and A.list are held. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:285</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph.png" border="0" usemap="#classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph" alt=""/></div>
<map name="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph" id="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph">
<area shape="rect" id="node2" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa" title="Ensures two the invariants observed by A.first and A.list are held. " alt="" coords="227,5,363,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9e0dbfcd1cda4ab3bc067b16f17f7f2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::backsolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a back solve of this matrix, assuming that it is lower triangular (stored column major). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the right hand side. </td></tr>
    <tr><td class="paramname">x</td><td>a storage vector for the solution (must be same size as b). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                                                                     {</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                assert(b.size() == x.size());</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                x = b;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                <span class="comment">// simple forward substitution</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>; i++) {</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                        x[i] /= <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][0];</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; k &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].size(); k++) {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                                x[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i][k]] -= x[i]*<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][k];</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                        }</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_aab335a46ece471fd0edf52540e24225a"><div class="ttname"><a href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">lil_sparse_matrix::m_n_cols</a></div><div class="ttdeci">int m_n_cols</div><div class="ttdoc">Number of cols in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:31</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e59d373ec514c8cb264da653d36f753"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual el_type <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::coeff </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the (i,j)th coefficient of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">offset</td><td>an optional search offset for use in linear search (start at offset instead of 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (i,j)th element of the matrix. </dd></dl>

<p>Implements <a class="el" href="classlil__sparse__matrix.html#a03af482b9f3d8c8b522dd5e49a2500ee">lil_sparse_matrix&lt; el_type &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        {       </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                <span class="comment">//invariant: first elem in each col of a is the diagonal elem if it exists.</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                <span class="keywordflow">if</span> (i == j) {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].size() == 0) <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                        <span class="keywordflow">return</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j][0] == i ? <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j][0] : 0);</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                }</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                </div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = offset, end = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].size(); k &lt; end; k++) {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j][k] == i) <span class="keywordflow">return</span> <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j][k];</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                }</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a327c165f0c90cd362dd14fc6421ebadd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::coeffRef </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a>, <a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>its</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index/value pointers to (i,j)th coefficient of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">its</td><td>a pair of pointers, one for the index of the found element, and the other for the value of the element. If the element is not found, the pointers point to the end of column j.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if (i,j)th element is nonzero, false otherwise. </dd></dl>
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        {       </div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].size(); k++) {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j][k] == i) {</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                                its = make_pair(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].begin() + k, <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j].begin() + k);</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                        }</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                its = make_pair(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].end(), <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j].end());</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa1d3045545357a8f33955a87dc55f3aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ensure_invariant </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_list</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures two the invariants observed by A.first and A.list are held. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>If this matrix is a lower triangular factor of another matrix:<ol type="1">
<li>On iteration k, first[i] will give the number of non-zero elements on col i of A before A(k, i).</li>
<li>On iteration k, list[i][ first[i] ] will contain the first element below or on index k of column i of A.</li>
</ol>
</dd>
<dd>
If this matrix is the matrix to be factored:<ol type="1">
<li>On iteration k, first[i] will give the number of non-zero elements on row i of A before A(i, k).</li>
<li>On iteration k, list[i][ first[i] ] will contain the first element right of or on index k of row i of A.</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>the column of con. </td></tr>
    <tr><td class="paramname">k</td><td>the iteration number. </td></tr>
    <tr><td class="paramname">con</td><td>the container to be swapped. </td></tr>
    <tr><td class="paramname">update_list</td><td>boolean indicating whether list or m_x/m_idx should be updated. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                                                                                                           {</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                <span class="keywordtype">int</span> offset;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        <span class="keywordflow">if</span> (update_list) offset = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[j];</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        <span class="keywordflow">else</span> offset = <a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>[j];</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        </div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                <span class="keywordflow">if</span> ((offset &gt;= (<span class="keywordtype">int</span>) con.size()) || con.empty() || con[offset] == k) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                </div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                <span class="keywordtype">int</span> i, min(offset);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                <span class="keywordflow">for</span> (i = offset; i &lt; (int) con.size(); i++) {</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                        <span class="keywordflow">if</span> (con[i] == k) {</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                                min = i; </div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( con[i] &lt; con[min] ) {</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                                min = i;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                        }</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                }</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                </div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                <span class="keywordflow">if</span> (update_list)</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                        std::swap(con[offset], con[min]);</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                        std::swap(con[offset], con[min]);</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                        std::swap(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j][offset], <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j][min]);</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                }</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlilc__matrix_html_a2ca57e0c3866ed0cf1f17f6253666ebb"><div class="ttname"><a href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">lilc_matrix::row_first</a></div><div class="ttdeci">std::vector&lt; int &gt; row_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:46</div></div>
<div class="ttc" id="classlilc__matrix_html_a36c12de6fccae4ac5a885e8aa60788e9"><div class="ttname"><a href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">lilc_matrix::col_first</a></div><div class="ttdeci">std::vector&lt; int &gt; col_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:47</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad343cd9b2f435f40a9866de050f63ce5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::find_level_set </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>lvl_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next level set given the current level set of A. This is essentially all neighbours of the currently enqueued nodes in breath-first search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lvl_set</td><td>the current level set (a list of nodes). </td></tr>
    <tr><td class="paramname">visited</td><td>all previously visited nodes. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                                                                                              {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        vector&lt;int&gt; new_set;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> node_it = lvl_set.begin(); node_it != lvl_set.end(); node_it++) {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*node_it].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*node_it].end(); it++) {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                        <span class="keywordflow">if</span> (!visited[*it]) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                                visited[*it] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;                                new_set.push_back(*it);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                        }</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;                }</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*node_it].begin(); it != <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*node_it].end(); it++) {</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                        <span class="keywordflow">if</span> (!visited[*it]) {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                                visited[*it] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                                new_set.push_back(*it);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                        }</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                }</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        }</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        <span class="keywordflow">if</span> (new_set.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        lvl_set.swap(new_set);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a46161695c5bfb0f43a7dedb9b9146fef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::find_root </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pseudo-peripheral root of A. This is essentially many chained breadth-first searchs across the graph of A (where A is viewed as an adjacency matrix). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>contains the initial node to seed the algorithm. A pseudo-peripheral root of A is stored in s at the end of the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                                                    {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        vector&lt;bool&gt; visited(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        vector&lt;int&gt; lvl_set;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        <span class="keywordtype">int</span> ls_max = 0, ls = 0;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                lvl_set.clear();</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;                std::fill(visited.begin(), visited.end(), <span class="keyword">false</span>);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                ls = 0;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;                </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;                lvl_set.push_back(s);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;                visited[s] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                <span class="keywordflow">while</span> (<a class="code" href="classlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5">find_level_set</a>(lvl_set, visited))</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                        ls++;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                <span class="keywordflow">if</span> (ls &gt; ls_max) {</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                        ls_max = ls;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                        <span class="keywordtype">int</span> deg, min_deg = <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = lvl_set.begin(); it != lvl_set.end(); it++) {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                                deg = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].size() + <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].size();</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].size() &gt; 0 &amp;&amp; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it][0] == *it) deg--;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                <span class="keywordflow">if</span> (deg &lt; min_deg) { <span class="comment">//should consider tie breaking by index later if needed.</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;                                        min_deg = deg;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                                        s = *it;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                                }</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                        }</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                }</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        }</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_aab335a46ece471fd0edf52540e24225a"><div class="ttname"><a href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">lil_sparse_matrix::m_n_cols</a></div><div class="ttdeci">int m_n_cols</div><div class="ttdoc">Number of cols in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:31</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
<div class="ttc" id="classlilc__matrix_html_ad343cd9b2f435f40a9866de050f63ce5"><div class="ttname"><a href="classlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5">lilc_matrix::find_level_set</a></div><div class="ttdeci">bool find_level_set(vector&lt; int &gt; &amp;lvl_set, vector&lt; bool &gt; &amp;visited)</div><div class="ttdoc">Returns the next level set given the current level set of A. This is essentially all neighbours of th...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_find_level_set.h:6</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afd669063a9594f4d33b01f24bf693edd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::forwardsolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a forward solve of this matrix, assuming that it is upper triangular (stored row major). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the right hand side. </td></tr>
    <tr><td class="paramname">x</td><td>a storage vector for the solution (must be same size as b). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                                                                        {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                assert(b.size() == x.size());</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                <span class="comment">// simple back substitution</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>-1; i &gt;= 0; i--) {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                        x[i] = b[i]/<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][0];</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; k &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].size(); k++) {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                                x[i] -= x[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i][k]]*<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][k]/<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][0];</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                        }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                }</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_aab335a46ece471fd0edf52540e24225a"><div class="ttname"><a href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">lil_sparse_matrix::m_n_cols</a></div><div class="ttdeci">int m_n_cols</div><div class="ttdoc">Number of cols in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:31</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1e027b8d354b29b8fcd9a7777835dc3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ildl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>fill_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>pp_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6a">pivot_type</a>&#160;</td>
          <td class="paramname"><em>piv_type</em> = <code><a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">pivot_type::BKP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an LDL' factorization of this matrix. </p>
<p>The pivoted matrix P'AP will be stored in place of A. In addition, the L and D factors of P'AP will be stored in L and D (so that P'AP = LDL'). The factorization is performed in crout order and follows the algorithm outlined in "Crout versions of the ILU factorization with pivoting for sparse symmetric matrices" by Li and Saad (2005).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>the L factor of this matrix. </td></tr>
    <tr><td class="paramname">D</td><td>the D factor of this matrix. </td></tr>
    <tr><td class="paramname">perm</td><td>the current permutation of A. </td></tr>
    <tr><td class="paramname">fill_factor</td><td>a parameter to control memory usage. Each column is guaranteed to have fewer than fill_factor*(nnz(A)/n_col(A)) elements. </td></tr>
    <tr><td class="paramname">tol</td><td>a parameter to control agressiveness of dropping. In each column, elements less than tol*norm(column) are dropped. </td></tr>
    <tr><td class="paramname">pp_tol</td><td>a parameter to control aggresiveness of pivoting. Allowable ranges are [0,inf). If the parameter is &gt;= 1, Bunch-Kaufman pivoting will be done in full. If the parameter is 0, partial pivoting will be turned off and the first non-zero pivot under the diagonal will be used. Choices close to 0 increase locality in pivoting (pivots closer to the diagonal are used) while choices closer to 1 increase the stability of pivoting. Useful for situations where you care more about preserving the structure of the matrix rather than bounding the size of its elements. </td></tr>
    <tr><td class="paramname">pivot_type</td><td>chooses the type of pivoting procedure used: threshold Bunch-Kaufman, or rook pivoting. If rook pivoting is chosen, pp_tol is ignored. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;{</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="comment">//----------------- initialize temporary variables --------------------//</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">int</span> ncols = <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(); <span class="comment">//number of cols in A.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordtype">int</span> lfil;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        <span class="keywordflow">if</span> (fill_factor &gt; 1e4) lfil = ncols; <span class="comment">//just incase users decide to enter a giant fill factor for fun...</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        <span class="keywordflow">else</span> lfil = 2*fill_factor*<a class="code" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a>()/ncols; <span class="comment">//roughly a factor of 2 since only lower tri. of A is stored</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        <span class="keyword">const</span> el_type alpha = (1.0+sqrt(17.0))/8.0;  <span class="comment">//for use in pivoting.</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        el_type w1(-1), wr(-1), d1(-1), dr(-1);         <span class="comment">//for use in bk-pivoting</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        el_type det_D, D_inv11, D_inv22, D_inv12;       <span class="comment">//for use in 2x2 pivots</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        el_type l_11, l_12;                                                     <span class="comment">//for use in 2x2 pivots</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        vector&lt;bool&gt; in_set(ncols, <span class="keyword">false</span>); <span class="comment">//bitset used for unsorted merges</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        <a class="code" href="classswap__struct.html">swap_struct&lt;el_type&gt;</a> s; <span class="comment">//struct containing temp vars used in pivoting.</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        <a class="code" href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">elt_vector_type</a> work(ncols, 0), temp(ncols, 0); </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <a class="code" href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">idx_vector_type</a> curr_nnzs, temp_nnzs;  <span class="comment">//non-zeros on current col.</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        curr_nnzs.reserve(ncols); <span class="comment">//reserves space for worse case (entire col is non-zero)</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        <span class="keywordtype">int</span> count = 0; <span class="comment">//the total number of nonzeros stored in L.</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="keywordtype">int</span> i, j, k, r, offset, col_size, col_size2(-1);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordtype">bool</span> size_two_piv = <span class="keyword">false</span>;      <span class="comment">//boolean indicating if the pivot is 2x2 or 1x1</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="comment">//--------------- allocate memory for L and D ------------------//</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        L.<a class="code" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">resize</a>(ncols, ncols); <span class="comment">//allocate a vector of size n for Llist as well</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        D.<a class="code" href="classblock__diag__matrix.html#aa2f3ffb9d4e198ab18262b702c79cadb">resize</a>(ncols );</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="comment">//------------------- main loop: factoring begins -------------------------//</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="keywordflow">for</span> (k = 0; k &lt; ncols; k++) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                <span class="comment">//curr nnz vector starts out empty and is cleared at the end of each loop iteration.</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                <span class="comment">//assign nonzeros indices of A(k:n, k) to curr_nnzs</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                curr_nnzs.assign (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].end());</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                <span class="comment">//assign nonzero values of A(k:n, k) to work</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                <span class="keywordflow">for</span> (j = 0; j &lt; (int) curr_nnzs.size(); j++) {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                        work[curr_nnzs[j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][j];</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                }</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                <span class="comment">//--------------begin pivoting--------------//</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="comment">// the pivoting below DEFINITELY needs to be refactored into a separate function</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                <span class="comment">//do delayed updates on current column. work = Sum_{i=0}^{k-1} L(k,i) * D(i,i) * L(k:n, i)</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                <span class="comment">//(the formula above generalizes to block matrix form in the case of 2x2 pivots).</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e">update</a>(k, work, curr_nnzs, L, D, in_set);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                <span class="comment">//store diagonal element in d1. set diagonal element in work vector to 0</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                <span class="comment">//since we want to find the maximum off-diagonal element.</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                d1 = work[k];</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                work[k] = 0;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                <span class="comment">//find maximum element in work and store its index in r.</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                w1 = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a>(work, curr_nnzs, r);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        <span class="keywordflow">if</span> (piv_type == <a class="code" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">pivot_type::BKP</a>) {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="comment">//we do partial pivoting here, where we take the first element u in the column that satisfies</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            <span class="comment">//|u| &gt; pp_tol*|wi|. for more information, consult &quot;A Partial Pivoting Strategy for Sparse </span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="comment">//Symmetric Matrix Decomposition&quot; by J.H. Liu (1987).</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            <span class="keywordtype">int</span> t = r; <span class="comment">//stores location of u </span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            el_type u = w1; <span class="comment">//stores value of u</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;            <span class="keywordflow">for</span> (i = 0; i &lt; (int) curr_nnzs.size(); i++) {</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                <span class="keywordflow">if</span> (abs(work[curr_nnzs[i]])-pp_tol*w1 &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a> ) {</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                    t = curr_nnzs[i];</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                    u = work[t];</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            }</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            </div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            <span class="comment">//bunch-kaufman partial pivoting is used below. for a more detailed reference,</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            <span class="comment">//refer to &quot;Accuracy and Stability of Numerical Algorithms.&quot; by Higham (2002).</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            <span class="comment">//------------------- begin bunch-kaufman pivoting ------------------//</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            <span class="keywordflow">if</span> (w1 &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                <span class="comment">//case 0: do nothing. pivot is k.</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (alpha * w1 - abs(d1)) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>  ) {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                <span class="comment">//case 1: do nothing. pivot is k.</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                <span class="comment">//since we are doing partial pivoting, we should treat u and t like wi and r, so</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                <span class="comment">//we&#39;ll just reassign wi and r. note: this has to go in the else clause since</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                <span class="comment">//we still use the old wi for case 0 and case 1.</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                w1 = u;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                r = t;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                offset = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r];</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                <span class="comment">//assign all nonzero indices and values in A(r, k:r) </span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                <span class="comment">//( not including A(r,r) ) to temp and temp_nnzs</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                <span class="keywordflow">for</span> (j = offset; j &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size(); j++) {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                    temp_nnzs.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j]);</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                    temp[<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j]] = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a>(r, list[r][j]);</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                <span class="comment">//assign nonzero indices of A(r:n, r) to temp_nnzs </span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                temp_nnzs.insert(temp_nnzs.end(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end());</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                <span class="comment">//assign nonzero values of to temp</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                <span class="keywordflow">for</span> (j = 0; j &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].size(); j++) {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                    temp[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r][j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r][j];</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                }</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                <span class="comment">//perform delayed updates on temp. temp = Sum_{i=0}^{k-1} L(r,i) * D(i,i) * L(k:n, i).</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                <span class="comment">//(the formula above generalizes to block matrix form in the case of 2x2 pivots).</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e">update</a>(r, temp, temp_nnzs, L, D, in_set);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                dr = temp[r];</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                temp[r] = 0;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                <span class="comment">//find maximum element in temp.</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                wr = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a>(temp, temp_nnzs, j);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                <span class="keywordflow">if</span> ((alpha*w1*w1 - abs(d1)*wr) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                    <span class="comment">//case 2: do nothing. pivot is k.</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                    </div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (alpha * wr - abs(dr)) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                    <span class="comment">//case 3: pivot is k with r: 1x1 pivot case.</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                    temp[r] = dr;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                    work[k] = d1;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                    <span class="comment">//--------pivot A and L ---------//</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                    <a class="code" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c">pivot</a>(s, in_set, L, k, r);</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                    <span class="comment">//----------pivot rest ----------//</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                    std::swap(d1, dr);</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                    <span class="comment">//permute perm</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                    std::swap(perm[k], perm[r]);</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                    work.swap(temp);    <span class="comment">//swap work with temp.</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                    std::swap(work[k], work[r]); <span class="comment">//swap kth and rth row of work</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                    curr_nnzs.swap(temp_nnzs);  <span class="comment">//swap curr_nnzs with temp_nnzs</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                    <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(curr_nnzs, k, r); <span class="comment">//swap k and r if they are present in curr_nnzs</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                    <span class="comment">//--------end pivot rest---------//</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                    <span class="comment">//case 4: pivot is k+1 with r: 2x2 pivot case.</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                    <span class="comment">//must advance list for 2x2 pivot since we are pivoting on col k+1</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                    <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k);</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                    <span class="comment">//for the same reason as above, we must advance L.first as well</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                    L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k);</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                    <span class="comment">//restore diagonal elements in work and temp</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                    temp[r] = dr;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                    work[k] = d1;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                    <span class="comment">//indicate that pivot is 2x2</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                    size_two_piv = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                    <span class="keywordflow">if</span> (k+1 != r) {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                        <span class="comment">//symmetrically permute row/col k+1 and r.</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                        <a class="code" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c">pivot</a>(s, in_set, L, k+1, r);</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                        <span class="comment">//----------pivot rest ----------//</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                        <span class="comment">//permute perm</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                        std::swap(perm[k+1], perm[r]);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                        <span class="comment">//swap rows k+1 and r of work and temp</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                        std::swap(work[k+1], work[r]);</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                        std::swap(temp[k+1], temp[r]);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                        <span class="comment">//swap k+1 and r in curr_nnzs and temp_nnzs</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(curr_nnzs, k+1, r);</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(temp_nnzs, k+1, r);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                    }</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                }</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            }</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;            <span class="comment">//--------------end bkp pivoting--------------//</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (piv_type == <a class="code" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aa97c60a3a4e61ee21e3f38a2f950fe293">pivot_type::ROOK</a>) {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            <span class="comment">//--------------begin rook pivoting--------------//</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;            i = k;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;            work[k] = d1;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            <span class="keywordflow">if</span> (alpha * w1 &lt;= abs(d1) + <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                <span class="comment">// do nothing</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                    <span class="comment">// assign nonzeros indices and values of A(k:n, r) to col_r_nnzs</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                    <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = temp_nnzs.begin(); it != temp_nnzs.end(); it++) {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                        temp[*it] = 0;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                    }</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                    temp_nnzs.clear();</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                    </div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                    offset = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r];</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                    <span class="comment">//assign all nonzero indices and values in A(r, k:r) </span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                    <span class="comment">//( not including A(r,r) ) to temp and temp_nnzs</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                    <span class="keywordflow">for</span> (j = offset; j &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size(); j++) {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                        temp_nnzs.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j]);</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                        temp[<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j]] = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a>(r, list[r][j]);</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                    }</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                    <span class="comment">//assign nonzero indices of A(r:n, r) to temp_nnzs </span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                    temp_nnzs.insert(temp_nnzs.end(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end());</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                    <span class="comment">//assign nonzero values of to temp</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                    <span class="keywordflow">for</span> (j = 0; j &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].size(); j++) {</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                        temp[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r][j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r][j];</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                    }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                    <span class="comment">//perform delayed updates on temp. temp = Sum_{i=0}^{k-1} L(r,i) * D(i,i) * L(k:n, i).</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                    <span class="comment">//(the formula above generalizes to block matrix form in the case of 2x2 pivots).</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                    <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e">update</a>(r, temp, temp_nnzs, L, D, in_set);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                    dr = temp[r];</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                    temp[r] = 0;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                    <span class="comment">//find maximum element in temp.</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                    wr = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a>(temp, temp_nnzs, j);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                    temp[r] = dr;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                    </div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                    <span class="keywordflow">if</span> (alpha * wr &lt;= abs(dr) + <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                        <span class="comment">// swap rows and columns k and r</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                        this-&gt;<a class="code" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c">pivot</a>(s, in_set, L, k, r);</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                        std::swap(perm[k], perm[r]);</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                        std::swap(temp[k], temp[r]);</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(temp_nnzs, k, r);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                        work.swap(temp);</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                        curr_nnzs.swap(temp_nnzs);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abs(w1 - wr) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                        size_two_piv = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                        <span class="comment">// swap rows and columns k and i, k+1 and r</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                        <span class="keywordflow">if</span> (k != i) {</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                            this-&gt;<a class="code" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c">pivot</a>(s, in_set, L, k, i);</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                            std::swap(perm[k], perm[i]);</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                            std::swap(work[k], work[i]);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                            std::swap(temp[k], temp[i]);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                            <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(curr_nnzs, k, i);</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                            <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(temp_nnzs, k, i);</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                        }</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                        L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k);</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                        <span class="keywordflow">if</span> (k+1 != r) {</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                            this-&gt;<a class="code" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c">pivot</a>(s, in_set, L, k+1, r);</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                            std::swap(perm[k+1], perm[r]);</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                            std::swap(work[k+1], work[r]);</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                            std::swap(temp[k+1], temp[r]);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                            <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(curr_nnzs, k+1, r);</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                            <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(temp_nnzs, k+1, r);</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                        }</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                        i = r;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                        w1 = wr;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                        r = j;</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                        work.swap(temp);</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                        curr_nnzs.swap(temp_nnzs);</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                    }</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                }</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="comment">//--------------end rook pivoting--------------//</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        }</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                <span class="comment">//erase diagonal element from non-zero indices (to exclude it from being dropped)</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                curr_nnzs.erase(std::remove(curr_nnzs.begin(), curr_nnzs.end(), k), curr_nnzs.end());</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                <span class="comment">//performs the dual dropping procedure.</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                <span class="keywordflow">if</span> (!size_two_piv) {</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                        <span class="comment">//perform dual dropping criteria on work</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2">drop_tol</a>(work, curr_nnzs, lfil, tol);</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                        <span class="comment">//erase diagonal 2x2 block from non-zero indices (to exclude it from being dropped)</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                        temp_nnzs.erase(std::remove(temp_nnzs.begin(), temp_nnzs.end(), k), temp_nnzs.end());</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                        curr_nnzs.erase(std::remove(curr_nnzs.begin(), curr_nnzs.end(), k+1), curr_nnzs.end());</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                        temp_nnzs.erase(std::remove(temp_nnzs.begin(), temp_nnzs.end(), k+1), temp_nnzs.end());</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                        </div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                        <span class="comment">//compute inverse of the 2x2 block diagonal pivot.</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                        det_D = d1*dr - work[k+1]*work[k+1];</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                        <span class="keywordflow">if</span> ( abs(det_D) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) det_D = 1e-6;  <span class="comment">//statically pivot;</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                        D_inv11 = dr/det_D;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                        D_inv22 = d1/det_D;</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                        D_inv12 = -work[k+1]/det_D;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                        </div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                        <span class="comment">//assign pivot to D (d1 is assigned to D(k,k) later)</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                        D.<a class="code" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3">off_diagonal</a>(k) = work[k+1];</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                        D[k+1] = dr;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                        </div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                        <span class="comment">//merge nonzeros of curr and temp together so iterating through them will be easier</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567">unordered_inplace_union</a>(curr_nnzs, temp_nnzs.begin(), temp_nnzs.end(), in_set);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                        </div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                        <span class="comment">//multiply inverse of pivot to work and temp (gives us two columns of l)</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                                l_11 = work[*it]*D_inv11 + temp[*it]*D_inv12;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                                l_12 = work[*it]*D_inv12 + temp[*it]*D_inv22;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                                </div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                                <span class="comment">//note that work and temp roughly share the same non-zero indices</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                                work[*it] = l_11;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                                temp[*it] = l_12;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                        }</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                        </div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                        <span class="comment">//since the work and temp non-zero indices are roughly the same,</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                        <span class="comment">//we can copy it over to temp_nnzs</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                        temp_nnzs.assign(curr_nnzs.begin(), curr_nnzs.end());</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                        </div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                        <span class="comment">//perform dual dropping procedure on work and temp</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2">drop_tol</a>(temp, temp_nnzs, lfil, tol);</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2">drop_tol</a>(work, curr_nnzs, lfil, tol);</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                        </div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                }</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                <span class="comment">//resize kth column of L to proper size.</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].resize(curr_nnzs.size()+1);</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k].resize(curr_nnzs.size()+1);</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                </div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                <span class="comment">//assign diagonal element to D</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                D[k] = d1;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                </div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                <span class="comment">//assign 1s to diagonal of L.</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][0] = 1;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][0] = k;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                count++;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                </div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                <span class="keywordflow">if</span> (!size_two_piv) {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                        <span class="keywordflow">if</span> ( abs(D[k]) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) D[k] = 1e-6; <span class="comment">//statically pivot</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                        i = 1;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) { </div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                                <span class="keywordflow">if</span> ( abs(work[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i] = *it; <span class="comment">//col k nonzero indices of L are stored</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i] = work[*it]/D[k]; <span class="comment">//col k nonzero values of L are stored</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                                        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].push_back(k); <span class="comment">//update Llist</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                                        count++;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                                        i++;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                                }</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                        }</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                        </div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                        col_size = i;</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                        </div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                        <span class="comment">//advance list and L.first</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                        L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k);</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k);</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                        <span class="comment">//resize k+1th column of L to proper size.</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1].resize(temp_nnzs.size()+1);</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1].resize(temp_nnzs.size()+1);</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                        <span class="comment">//assign 1s to diagonal of L.</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1][0] = 1;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1][0] = k+1;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                        count++;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                        i = 1;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                                <span class="keywordflow">if</span> ( abs(work[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i] = work[*it]; <span class="comment">//col k nonzero indices of L are stored</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i] = *it; <span class="comment">//col k nonzero values of L are stored</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                                        </div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                                        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].push_back(k); <span class="comment">//update L.list</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                                        count++;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                                        i++;</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                                }</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                                </div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                        }</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                        </div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                        j = 1;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = temp_nnzs.begin(); it != temp_nnzs.end(); it++) {</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                                <span class="keywordflow">if</span> ( abs(temp[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1][j] = temp[*it]; <span class="comment">//col k+1 nonzero indices of L are stored</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1][j] = *it; <span class="comment">//col k+1 nonzero values of L are stored</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;                                        </div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                                        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].push_back(k+1); <span class="comment">//update L.list</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;                                        count++;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                                        j++;</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                                }</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                                </div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                        }</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                        col_size = i;</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                        col_size2 = j;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                        <span class="comment">//update list and L.first</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                        L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k+1);</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k+1);</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                        </div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                }</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                </div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                <span class="comment">// ------------- reset temp and work back to zero -----------------//</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                work[k] = 0;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                temp[k] = 0;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                </div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                <span class="keywordflow">if</span> (k + 1 &lt; ncols) {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                        temp[k+1] = 0;</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                        work[k+1] = 0;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                </div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                        work[*it] = 0;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                }</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                curr_nnzs.clear(); <span class="comment">//zero out work vector</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                </div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = temp_nnzs.begin(); it != temp_nnzs.end(); it++) {</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                        temp[*it] = 0;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                }</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                temp_nnzs.clear(); <span class="comment">//zero out work vector</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                </div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                <span class="comment">//-------------------------------------------------------------------//</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                </div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                <span class="comment">//resize columns of L to correct size</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k].resize(col_size);</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].resize(col_size);</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                <span class="keywordflow">if</span> (size_two_piv) {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1].resize(col_size2);</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1].resize(col_size2);</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                        k++;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                        </div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                        size_two_piv = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                }</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        }</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        <span class="comment">//assign number of non-zeros in L to L.nnz_count</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        L.<a class="code" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">nnz_count</a> = count;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;}</div>
<div class="ttc" id="classlilc__matrix_html_ab9ee09328b84657630f52631ea8e5eb1"><div class="ttname"><a href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">lilc_matrix::advance_list</a></div><div class="ttdeci">void advance_list(const int &amp;k)</div><div class="ttdoc">Updates A.list for iteration k. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:323</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_acdc8477f4f3893490bbf0b196438fab8"><div class="ttname"><a href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">lil_sparse_matrix::nnz_count</a></div><div class="ttdeci">int nnz_count</div><div class="ttdoc">Number of nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:32</div></div>
<div class="ttc" id="classblock__diag__matrix_html_aa57572352da969e948428ad7521a1ce3"><div class="ttname"><a href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3">block_diag_matrix::off_diagonal</a></div><div class="ttdeci">el_type &amp; off_diagonal(int i)</div><div class="ttdef"><b>Definition:</b> block_diag_matrix.h:111</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlilc__matrix_html_a83c70482c28275881562ee3937b5f591"><div class="ttname"><a href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">lilc_matrix::idx_vector_type</a></div><div class="ttdeci">lil_sparse_matrix&lt; el_type &gt;::idx_vector_type idx_vector_type</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:38</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a1ff3caa5707b4757ef6286017c9ded5e"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e">update</a></div><div class="ttdeci">void update(const int &amp;r, vector&lt; el_type &gt; &amp;work, vector&lt; int &gt; &amp;curr_nnzs, lilc_matrix&lt; el_type &gt; &amp;L, block_diag_matrix&lt; el_type &gt; &amp;D, vector&lt; bool &gt; &amp;in_set)</div><div class="ttdoc">Performs a delayed update of subcolumn A(k:n,r). Result is stored in work vector. Nonzero elements of...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:216</div></div>
<div class="ttc" id="classlilc__matrix_html_a2ca57e0c3866ed0cf1f17f6253666ebb"><div class="ttname"><a href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">lilc_matrix::row_first</a></div><div class="ttdeci">std::vector&lt; int &gt; row_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:46</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_af0e67313612267ba689bc7625a691567"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567">unordered_inplace_union</a></div><div class="ttdeci">void unordered_inplace_union(InputContainer &amp;a, InputIterator const &amp;b_start, InputIterator const &amp;b_end, vector&lt; bool &gt; &amp;in_set)</div><div class="ttdoc">Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:137</div></div>
<div class="ttc" id="classblock__diag__matrix_html_aa2f3ffb9d4e198ab18262b702c79cadb"><div class="ttname"><a href="classblock__diag__matrix.html#aa2f3ffb9d4e198ab18262b702c79cadb">block_diag_matrix::resize</a></div><div class="ttdeci">void resize(int n, el_type default_value)</div><div class="ttdoc">Resizes this matrix to an n*n matrix with default_value on the main diagonal. </div><div class="ttdef"><b>Definition:</b> block_diag_matrix.h:68</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classlilc__matrix_html_a177dde39764c88fe4e82b050a5e60303"><div class="ttname"><a href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">lilc_matrix::advance_first</a></div><div class="ttdeci">void advance_first(const int &amp;k)</div><div class="ttdoc">Updates A.first for iteration k. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:313</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_af764d0312eb9f7939ab144b12972bf56"><div class="ttname"><a href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">lil_sparse_matrix::eps</a></div><div class="ttdeci">el_type eps</div><div class="ttdoc">Machine epsilon for el_type. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:33</div></div>
<div class="ttc" id="classlilc__matrix_html_a9c53c4a5816e0e21a167044f07b2ba6aa97c60a3a4e61ee21e3f38a2f950fe293"><div class="ttname"><a href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aa97c60a3a4e61ee21e3f38a2f950fe293">lilc_matrix::pivot_type::ROOK</a></div></div>
<div class="ttc" id="classswap__struct_html"><div class="ttname"><a href="classswap__struct.html">swap_struct</a></div><div class="ttdoc">A structure containing variables used in pivoting a LIL-C matrix. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:6</div></div>
<div class="ttc" id="classlilc__matrix_html_ad2c9a672941d6b47d3c60f631d21078c"><div class="ttname"><a href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c">lilc_matrix::pivot</a></div><div class="ttdeci">void pivot(swap_struct&lt; el_type &gt; s, vector&lt; bool &gt; &amp;in_set, lilc_matrix&lt; el_type &gt; &amp;L, const int &amp;k, const int &amp;r)</div><div class="ttdoc">Performs a symmetric permutation between row/col k & r of A. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_pivot.h:14</div></div>
<div class="ttc" id="classlilc__matrix_html_aa5a7b6e31a6c9ebf2ea3a898fe646af6"><div class="ttname"><a href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">lilc_matrix::elt_vector_type</a></div><div class="ttdeci">lil_sparse_matrix&lt; el_type &gt;::elt_vector_type elt_vector_type</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:39</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a281d3bdc2bb15862886008e2ea39a1e2"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2">drop_tol</a></div><div class="ttdeci">void drop_tol(vector&lt; el_type &gt; &amp;v, vector&lt; int &gt; &amp;curr_nnzs, const int &amp;lfil, const double &amp;tol)</div><div class="ttdoc">Performs the dual-dropping criteria outlined in Li & Saad (2005). </div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:166</div></div>
<div class="ttc" id="classlilc__matrix_html_a0e59d373ec514c8cb264da653d36f753"><div class="ttname"><a href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">lilc_matrix::coeff</a></div><div class="ttdeci">virtual el_type coeff(const int &amp;i, const int &amp;j, int offset=0) const </div><div class="ttdoc">Finds the (i,j)th coefficient of the matrix. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:76</div></div>
<div class="ttc" id="classlilc__matrix_html_aca815e0ac073abb1e6ef888b09f9e795"><div class="ttname"><a href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">lilc_matrix::resize</a></div><div class="ttdeci">void resize(int n_rows, int n_cols)</div><div class="ttdoc">Resizes the matrix. For use in preallocating space before factorization begins. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:115</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a7319334b43609089b10764dcd0df64cb"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a></div><div class="ttdeci">double max(vector&lt; el_type &gt; &amp;v, vector&lt; int &gt; &amp;curr_nnzs, int &amp;r)</div><div class="ttdoc">Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:40</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a40bc09d3b6716e57134eed0aeba49199"><div class="ttname"><a href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">lil_sparse_matrix::nnz</a></div><div class="ttdeci">int nnz() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:58</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac88631204bcf7c9a223fb082a7d0cd3d"><div class="ttname"><a href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">lil_sparse_matrix::n_cols</a></div><div class="ttdeci">int n_cols() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:52</div></div>
<div class="ttc" id="classlilc__matrix_html_a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b"><div class="ttname"><a href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">lilc_matrix::pivot_type::BKP</a></div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a9c060e7f9ab18bfcd8386b523f36b0e1"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a></div><div class="ttdeci">void safe_swap(vector&lt; int &gt; &amp;curr_nnzs, const int &amp;k, const int &amp;r)</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:251</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a1e027b8d354b29b8fcd9a7777835dc3f_cgraph.png" border="0" usemap="#classlilc__matrix_a1e027b8d354b29b8fcd9a7777835dc3f_cgraph" alt=""/></div>
<map name="classlilc__matrix_a1e027b8d354b29b8fcd9a7777835dc3f_cgraph" id="classlilc__matrix_a1e027b8d354b29b8fcd9a7777835dc3f_cgraph">
<area shape="rect" id="node2" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795" title="Resizes the matrix. For use in preallocating space before factorization begins. " alt="" coords="169,85,300,111"/><area shape="rect" id="node5" href="classblock__diag__matrix.html#aa2f3ffb9d4e198ab18262b702c79cadb" title="Resizes this matrix to an n*n matrix with default_value on the main diagonal. " alt="" coords="356,136,499,177"/><area shape="rect" id="node6" href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e" title="Performs a delayed update of subcolumn A(k:n,r). Result is stored in work vector. Nonzero elements of..." alt="" coords="201,277,268,303"/><area shape="rect" id="node10" href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567" title="Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list..." alt="" coords="547,326,732,353"/><area shape="rect" id="node12" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3" title="block_diag_matrix::\loff_diagonal" alt="" coords="356,421,499,463"/><area shape="rect" id="node13" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index. " alt="" coords="211,378,259,405"/><area shape="rect" id="node14" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1" title="safe_swap" alt="" coords="189,429,280,455"/><area shape="rect" id="node15" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303" title="Updates A.first for iteration k. " alt="" coords="161,480,308,521"/><area shape="rect" id="node16" href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2" title="Performs the dual&#45;dropping criteria outlined in Li &amp; Saad (2005). " alt="" coords="197,546,272,573"/><area shape="rect" id="node3" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0" title="lil_sparse_matrix::\ln_rows" alt="" coords="359,71,495,112"/><area shape="rect" id="node4" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d" title="lil_sparse_matrix::\ln_cols" alt="" coords="359,5,495,47"/><area shape="rect" id="node7" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753" title="Finds the (i,j)th coefficient of the matrix. " alt="" coords="367,253,488,279"/><area shape="rect" id="node8" href="lilc__matrix__ildl__helpers_8h.html#a737792b9fd3b712d9b15578a3f067f3c" title="update_single" alt="" coords="371,370,483,397"/><area shape="rect" id="node11" href="classblock__diag__matrix.html#ad2a00befe5b5c5718e222fa99cbbefd2" title="block_diag_matrix::\lblock_size" alt="" coords="356,304,499,345"/><area shape="rect" id="node9" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa" title="Ensures two the invariants observed by A.first and A.list are held. " alt="" coords="571,407,707,448"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8cc83364ccef8d296e7dabed833d865c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ildl_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>fill_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>pp_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6a">pivot_type</a>&#160;</td>
          <td class="paramname"><em>piv_type</em> = <code><a class="el" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">pivot_type::BKP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an <em>inplace</em> LDL' factorization of this matrix. </p>
<p>The pivoted matrix P'AP will be stored in place of A. In addition, the L and D factors of P'AP will be stored in L and D (so that P'AP = LDL'). The factorization is performed in crout order and follows the algorithm outlined in "Crout versions of the ILU factorization with pivoting for sparse symmetric matrices" by Li and Saad (2005).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>the D factor of this matrix. </td></tr>
    <tr><td class="paramname">perm</td><td>the current permutation of A. </td></tr>
    <tr><td class="paramname">fill_factor</td><td>a parameter to control memory usage. Each column is guaranteed to have fewer than fill_factor*(nnz(A)/n_col(A)) elements. </td></tr>
    <tr><td class="paramname">tol</td><td>a parameter to control agressiveness of dropping. In each column, elements less than tol*norm(column) are dropped. </td></tr>
    <tr><td class="paramname">pp_tol</td><td>a parameter to control aggresiveness of pivoting. Allowable ranges are [0,inf). If the parameter is &gt;= 1, Bunch-Kaufman pivoting will be done in full. If the parameter is 0, partial pivoting will be turned off and the first non-zero pivot under the diagonal will be used. Choices close to 0 increase locality in pivoting (pivots closer to the diagonal are used) while choices closer to 1 increase the stability of pivoting. Useful for situations where you care more about preserving the structure of the matrix rather than bounding the size of its elements. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;{</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="comment">//----------------- initialize temporary variables --------------------//</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">int</span> ncols = <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(); <span class="comment">//number of cols in A.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordtype">int</span> lfil;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        <span class="keywordflow">if</span> (fill_factor &gt; 1e4) lfil = ncols; <span class="comment">//just incase users decide to enter a giant fill factor for fun...</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        <span class="keywordflow">else</span> lfil = 2*fill_factor*<a class="code" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a>()/ncols; <span class="comment">//roughly a factor of 2 since only lower tri. of A is stored</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        <span class="keyword">const</span> el_type alpha = (1.0+sqrt(17.0))/8.0;  <span class="comment">//for use in pivoting.</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        el_type w1(-1), wr(-1), d1(-1), dr(-1);         <span class="comment">//for use in bk-pivoting</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        el_type det_D, D_inv11, D_inv22, D_inv12;       <span class="comment">//for use in 2x2 pivots</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        el_type l_11, l_12;                                                     <span class="comment">//for use in 2x2 pivots</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        vector&lt;bool&gt; in_set(ncols, <span class="keyword">false</span>); <span class="comment">//bitset used for unsorted merges</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        <a class="code" href="classswap__struct.html">swap_struct&lt;el_type&gt;</a> s; <span class="comment">//struct containing temp vars used in pivoting.</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        <a class="code" href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">elt_vector_type</a> work(ncols, 0), temp(ncols, 0); </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <a class="code" href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">idx_vector_type</a> curr_nnzs, temp_nnzs;  <span class="comment">//non-zeros on current col.</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        curr_nnzs.reserve(ncols); <span class="comment">//reserves space for worse case (entire col is non-zero)</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        <span class="keywordtype">int</span> count = 0; <span class="comment">//the total number of nonzeros stored in L.</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="keywordtype">int</span> i, j, k, r, offset, col_size, col_size2(-1);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <span class="keywordtype">bool</span> size_two_piv = <span class="keyword">false</span>;      <span class="comment">//boolean indicating if the pivot is 2x2 or 1x1</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="comment">//--------------- allocate memory for L and D ------------------//</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        D.<a class="code" href="classblock__diag__matrix.html#aa2f3ffb9d4e198ab18262b702c79cadb">resize</a>(ncols);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        </div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="comment">//------------------- main loop: factoring begins -------------------------//</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keywordflow">for</span> (k = 0; k &lt; ncols; k++) {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                <span class="comment">//curr nnz vector starts out empty and is cleared at the end of each loop iteration.</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                <span class="comment">//assign nonzeros indices of A(k:n, k) to curr_nnzs</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                curr_nnzs.assign (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].end());</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                <span class="comment">//assign nonzero values of A(k:n, k) to work</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                <span class="keywordflow">for</span> (j = 0; j &lt; (int) curr_nnzs.size(); j++) {</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                        work[curr_nnzs[j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][j];</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                }</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        </div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                <span class="comment">//--------------begin pivoting--------------//</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                <span class="comment">//do delayed updates on current column. work = Sum_{i=0}^{k-1} L(k,i) * D(i,i) * L(k:n, i)</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                <span class="comment">//(the formula above generalizes to block matrix form in the case of 2x2 pivots).</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e">update</a>(k, work, curr_nnzs, *<span class="keyword">this</span>, D, in_set);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                <span class="comment">//store diagonal element in d1. set diagonal element in work vector to 0</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                <span class="comment">//since we want to find the maximum off-diagonal element.</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                d1 = work[k];</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                work[k] = 0;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                <span class="comment">//find maximum element in work and store its index in r.</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                w1 = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a>(work, curr_nnzs, r);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">if</span> (piv_type == <a class="code" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">pivot_type::BKP</a>) {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="comment">//we do partial pivoting here, where we take the first element u in the column that satisfies</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            <span class="comment">//|u| &gt; pp_tol*|wi|. for more information, consult &quot;A Partial Pivoting Strategy for Sparse </span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            <span class="comment">//Symmetric Matrix Decomposition&quot; by J.H. Liu (1987).</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordtype">int</span> t = r; <span class="comment">//stores location of u </span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;            el_type u = w1; <span class="comment">//stores value of u</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keywordflow">for</span> (i = 0; i &lt; (int) curr_nnzs.size(); i++) {</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                <span class="keywordflow">if</span> (abs(work[curr_nnzs[i]])-pp_tol*w1 &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a> ) {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                    t = curr_nnzs[i];</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                    u = work[t];</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                }</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            }</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <span class="comment">//bunch-kaufman partial pivoting is used below. for a more detailed reference,</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            <span class="comment">//refer to &quot;Accuracy and Stability of Numerical Algorithms.&quot; by Higham (2002).</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;            <span class="comment">//------------------- begin bunch-kaufman pivoting ------------------//</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;            <span class="keywordflow">if</span> (w1 &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                <span class="comment">//case 0: do nothing. pivot is k.</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (alpha * w1 - abs(d1)) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>  ) {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                <span class="comment">//case 1: do nothing. pivot is k.</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                <span class="comment">//since we are doing partial pivoting, we should treat u and t like wi and r, so</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                <span class="comment">//we&#39;ll just reassign wi and r. note: this has to go in the else clause since</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                <span class="comment">//we still use the old wi for case 0 and case 1.</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                w1 = u;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                r = t;</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                </div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                offset = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r];</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                <span class="comment">//assign all nonzero indices and values in A(r, k:r) </span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                <span class="comment">//( not including A(r,r) ) to temp and temp_nnzs</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                <span class="keywordflow">for</span> (j = offset; j &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size(); j++) {</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                    temp_nnzs.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j]);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                    temp[<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j]] = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a>(r, list[r][j]);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                }</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                <span class="comment">//assign nonzero indices of A(r:n, r) to temp_nnzs </span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                temp_nnzs.insert(temp_nnzs.end(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end());</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                <span class="comment">//assign nonzero values of to temp</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                <span class="keywordflow">for</span> (j = 0; j &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].size(); j++) {</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                    temp[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r][j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r][j];</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                }</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                <span class="comment">//perform delayed updates on temp. temp = Sum_{i=0}^{k-1} L(r,i) * D(i,i) * L(k:n, i).</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                <span class="comment">//(the formula above generalizes to block matrix form in the case of 2x2 pivots).</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e">update</a>(r, temp, temp_nnzs, *<span class="keyword">this</span>, D, in_set);</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                dr = temp[r];</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                temp[r] = 0;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                <span class="comment">//find maximum element in temp.</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                wr = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a>(temp, temp_nnzs, j);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                <span class="keywordflow">if</span> ((alpha*w1*w1 - abs(d1)*wr) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                    <span class="comment">//case 2: do nothing. pivot is k.</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                    </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (alpha * wr - abs(dr)) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                    <span class="comment">//case 3: pivot is k with r: 1x1 pivot case.</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                    temp[r] = dr;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                    work[k] = d1;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                    <span class="comment">//--------pivot A ---------//</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                    <a class="code" href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">pivotA</a>(s, in_set, k, r);</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                    <span class="comment">//----------pivot rest ----------//</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                    std::swap(d1, dr);</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                    <span class="comment">//permute perm</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                    std::swap(perm[k], perm[r]);</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                    work.swap(temp);    <span class="comment">//swap work with temp.</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                    std::swap(work[k], work[r]); <span class="comment">//swap kth and rth row of work</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                    curr_nnzs.swap(temp_nnzs);  <span class="comment">//swap curr_nnzs with temp_nnzs</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                    <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(curr_nnzs, k, r); <span class="comment">//swap k and r if they are present in curr_nnzs</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                    <span class="comment">//--------end pivot rest---------//</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                    <span class="comment">//case 4: pivot is k+1 with r: 2x2 pivot case.</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                    </div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                    <span class="comment">// remote col k for convenience while we are pivoting on col k+1</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].size(); i++) {</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                        <span class="keywordtype">int</span> l = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i];</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                        <span class="keywordflow">if</span> (l == k) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[l]; j &lt; <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[l].size(); j++) {</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                            <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[l][j] == k) {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                                std::swap(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[l][j], <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[l][<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[l].size()-1]);</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[l].pop_back();</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                            }</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                        }</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                    }</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                    <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k].clear();</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                    <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].clear();</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                    <a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>[k] = 0;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                    <span class="comment">//restore diagonal elements in work and temp</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                    temp[r] = dr;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                    work[k] = d1;</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                    <span class="comment">//indicate that pivot is 2x2</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                    size_two_piv = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                    <span class="keywordflow">if</span> (k+1 != r) {</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                        <span class="comment">//symmetrically permute row/col k+1 and r.</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                        <a class="code" href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">pivotA</a>(s, in_set, k+1, r);</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                        </div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                        <span class="comment">//----------pivot rest ----------//</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                        <span class="comment">//permute perm</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                        std::swap(perm[k+1], perm[r]);</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                        <span class="comment">//swap rows k+1 and r of work and temp</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                        std::swap(work[k+1], work[r]);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                        std::swap(temp[k+1], temp[r]);</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                        <span class="comment">//swap k+1 and r in curr_nnzs and temp_nnzs</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(curr_nnzs, k+1, r);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(temp_nnzs, k+1, r);</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                    }</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                }</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;            }</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="comment">//--------------end bkp pivoting--------------//</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (piv_type == <a class="code" href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aa97c60a3a4e61ee21e3f38a2f950fe293">pivot_type::ROOK</a>) {</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="comment">//--------------begin rook pivoting--------------//</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            i = k;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;            work[k] = d1;</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;            <span class="keywordflow">if</span> (alpha * w1 &lt;= abs(d1) + <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                <span class="comment">// do nothing</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                    <span class="comment">// assign nonzeros indices and values of A(k:n, r) to col_r_nnzs</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                    <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = temp_nnzs.begin(); it != temp_nnzs.end(); it++) {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                        temp[*it] = 0;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                    }</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                    temp_nnzs.clear();</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                    </div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                    offset = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r];</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                    <span class="comment">//assign all nonzero indices and values in A(r, k:r) </span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                    <span class="comment">//( not including A(r,r) ) to temp and temp_nnzs</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                    <span class="keywordflow">for</span> (j = offset; j &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size(); j++) {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                        temp_nnzs.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j]);</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                        temp[<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j]] = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a>(r, list[r][j]);</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                    }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                    <span class="comment">//assign nonzero indices of A(r:n, r) to temp_nnzs </span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                    temp_nnzs.insert(temp_nnzs.end(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end());</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                    <span class="comment">//assign nonzero values of to temp</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                    <span class="keywordflow">for</span> (j = 0; j &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].size(); j++) {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                        temp[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r][j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r][j];</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                    }</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                    <span class="comment">//perform delayed updates on temp. temp = Sum_{i=0}^{k-1} L(r,i) * D(i,i) * L(k:n, i).</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                    <span class="comment">//(the formula above generalizes to block matrix form in the case of 2x2 pivots).</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                    <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e">update</a>(r, temp, temp_nnzs, *<span class="keyword">this</span>, D, in_set);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                    dr = temp[r];</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                    temp[r] = 0;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                    <span class="comment">//find maximum element in temp.</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                    wr = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a>(temp, temp_nnzs, j);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                    temp[r] = dr;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                    </div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                    <span class="keywordflow">if</span> (alpha * wr &lt;= abs(dr) + <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                        <span class="comment">// swap rows and columns k and r</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                        this-&gt;<a class="code" href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">pivotA</a>(s, in_set, k, r);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                        std::swap(perm[k], perm[r]);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                        std::swap(temp[k], temp[r]);</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(temp_nnzs, k, r);</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                        work.swap(temp);</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                        curr_nnzs.swap(temp_nnzs);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abs(w1 - wr) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                        size_two_piv = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                        <span class="comment">// swap rows and columns k and i, k+1 and r</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                        <span class="keywordflow">if</span> (k != i) {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                            this-&gt;<a class="code" href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">pivotA</a>(s, in_set, k, i);</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                            std::swap(perm[k], perm[i]);</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                            std::swap(work[k], work[i]);</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                            std::swap(temp[k], temp[i]);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                            <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(curr_nnzs, k, i);</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                            <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(temp_nnzs, k, i);</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                        }</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                        <span class="keywordflow">if</span> (k+1 != r) {</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                            this-&gt;<a class="code" href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">pivotA</a>(s, in_set, k+1, r);</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                            std::swap(perm[k+1], perm[r]);</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                            std::swap(work[k+1], work[r]);</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                            std::swap(temp[k+1], temp[r]);</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                            <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(curr_nnzs, k+1, r);</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                            <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(temp_nnzs, k+1, r);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                        }</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                        i = r;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                        w1 = wr;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                        r = j;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                        work.swap(temp);</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                        curr_nnzs.swap(temp_nnzs);</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                    }</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            }</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="comment">//--------------end rook pivoting--------------//</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        </div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                <span class="comment">//erase diagonal element from non-zero indices (to exclude it from being dropped)</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                curr_nnzs.erase(std::remove(curr_nnzs.begin(), curr_nnzs.end(), k), curr_nnzs.end());</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                <span class="comment">//performs the dual dropping procedure.</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                <span class="keywordflow">if</span> (!size_two_piv) {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                        <span class="comment">//perform dual dropping criteria on work</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2">drop_tol</a>(work, curr_nnzs, lfil, tol);</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                        <span class="comment">//erase diagonal 2x2 block from non-zero indices (to exclude it from being dropped)</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                        temp_nnzs.erase(std::remove(temp_nnzs.begin(), temp_nnzs.end(), k), temp_nnzs.end());</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                        curr_nnzs.erase(std::remove(curr_nnzs.begin(), curr_nnzs.end(), k+1), curr_nnzs.end());</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                        temp_nnzs.erase(std::remove(temp_nnzs.begin(), temp_nnzs.end(), k+1), temp_nnzs.end());</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                        </div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                        <span class="comment">//compute inverse of the 2x2 block diagonal pivot.</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                        det_D = d1*dr - work[k+1]*work[k+1];</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                        <span class="keywordflow">if</span> ( abs(det_D) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) det_D = 1e-6;  <span class="comment">//statically pivot;</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                        D_inv11 = dr/det_D;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                        D_inv22 = d1/det_D;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                        D_inv12 = -work[k+1]/det_D;</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                        </div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                        <span class="comment">//assign pivot to D (d1 is assigned to D(k,k) later)</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                        D.<a class="code" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3">off_diagonal</a>(k) = work[k+1];</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                        D[k+1] = dr;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                        </div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                        <span class="comment">//merge nonzeros of curr and temp together so iterating through them will be easier</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567">unordered_inplace_union</a>(curr_nnzs, temp_nnzs.begin(), temp_nnzs.end(), in_set);</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                        </div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                        <span class="comment">//multiply inverse of pivot to work and temp (gives us two columns of l)</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                                l_11 = work[*it]*D_inv11 + temp[*it]*D_inv12;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                                l_12 = work[*it]*D_inv12 + temp[*it]*D_inv22;</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                                </div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                                <span class="comment">//note that work and temp roughly share the same non-zero indices</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                                work[*it] = l_11;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                                temp[*it] = l_12;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                        }</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                        </div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                        <span class="comment">//since the work and temp non-zero indices are roughly the same,</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                        <span class="comment">//we can copy it over to temp_nnzs</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                        temp_nnzs.assign(curr_nnzs.begin(), curr_nnzs.end());</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                        </div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                        <span class="comment">//perform dual dropping procedure on work and temp</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2">drop_tol</a>(temp, temp_nnzs, lfil, tol);</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2">drop_tol</a>(work, curr_nnzs, lfil, tol);</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                }</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        <span class="comment">// remove current column for list, and add new column back in (inplace)</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].size(); i++) {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;            r = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i];</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            <span class="keywordflow">if</span> (r == k) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            <span class="keywordflow">for</span> (j = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r]; j &lt; <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size(); j++) {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j] == k) {</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                    std::swap(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j], <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size()-1]);</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                    <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].pop_back();</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                    <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                }</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            }</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        }</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        </div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                <span class="comment">//resize kth column of L to proper size.</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].resize(curr_nnzs.size()+1);</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k].resize(curr_nnzs.size()+1);</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                </div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                <span class="comment">//assign diagonal element to D</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                D[k] = d1;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                <span class="comment">//assign 1s to diagonal of L.</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][0] = 1;</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][0] = k;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                count++;</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                </div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                <span class="keywordflow">if</span> (!size_two_piv) {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                        <span class="keywordflow">if</span> ( abs(D[k]) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) D[k] = 1e-6; <span class="comment">//statically pivot</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                        i = 1;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) { </div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                                <span class="keywordflow">if</span> ( abs(work[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                                        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i] = *it; <span class="comment">//col k nonzero indices of L are stored</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i] = work[*it]/D[k]; <span class="comment">//col k nonzero values of L are stored</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                    </div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                    <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].push_back(k); <span class="comment">//update Llist</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                                        count++;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                                        i++;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                                }</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                        }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                        </div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                        col_size = i;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;            <span class="comment">// remove occurences of current column from list, and add in new column</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;            <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1].size(); i++) {</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                r = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1][i];</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                <span class="keywordflow">if</span> (r == k+1) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                <span class="keywordflow">for</span> (j = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r]; j &lt; <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size(); j++) {</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                    <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j] == k+1) {</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                        std::swap(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][j], <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size()-1]);</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].pop_back();</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                    }</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;                }</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            }</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;            </div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                        i = 1;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                                <span class="keywordflow">if</span> ( abs(work[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;                                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i] = work[*it]; <span class="comment">//col k nonzero indices of L are stored</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                                        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i] = *it; <span class="comment">//col k nonzero values of L are stored</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                                        </div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                                        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].push_back(k); <span class="comment">//update Llist</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;                                        count++;</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;                                        i++;</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;                                }</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                                </div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                        }</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            </div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;            <span class="comment">//resize k+1th column of L to proper size.</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1].resize(temp_nnzs.size()+1);</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1].resize(temp_nnzs.size()+1);</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;                        <span class="comment">//assign 1s to diagonal of L.</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1][0] = 1;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;                        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1][0] = k+1;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                        count++;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            </div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                        j = 1;</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = temp_nnzs.begin(); it != temp_nnzs.end(); it++) {</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                                <span class="keywordflow">if</span> ( abs(temp[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1][j] = temp[*it]; <span class="comment">//col k+1 nonzero indices of L are stored</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                                        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1][j] = *it; <span class="comment">//col k+1 nonzero values of L are stored</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                                        </div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                    <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].push_back(k+1); <span class="comment">//update Llist</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                                        count++;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                                        j++;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;                                }</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;                                </div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                        }</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                        col_size = i;</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                        col_size2 = j;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                }</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                </div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                <span class="comment">// ------------- reset temp and work back to zero -----------------//</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                work[k] = 0;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;                temp[k] = 0;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                </div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                <span class="keywordflow">if</span> (k + 1 &lt; ncols) {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;                        temp[k+1] = 0;</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;                        work[k+1] = 0;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                }</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                </div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                        work[*it] = 0;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                }</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                curr_nnzs.clear(); <span class="comment">//zero out work vector</span></div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                </div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = temp_nnzs.begin(); it != temp_nnzs.end(); it++) {</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                        temp[*it] = 0;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                }</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                temp_nnzs.clear(); <span class="comment">//zero out work vector</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                </div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                <span class="comment">//-------------------------------------------------------------------//</span></div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;                </div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                <span class="comment">//resize columns of L to correct size</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k].resize(col_size);</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].resize(col_size);</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        </div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        <span class="comment">//update list and L.first</span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>[k] = 1;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k);</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        <a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k);</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        </div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                <span class="keywordflow">if</span> (size_two_piv) {</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1].resize(col_size2);</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1].resize(col_size2);</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                        </div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;            <a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>[k+1] = 1;</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                        <a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k+1);</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k+1);</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;            </div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            k++;</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                        </div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                        size_two_piv = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                }</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;        }</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="comment">//assign number of non-zeros in L to L.nnz_count</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        this-&gt;<a class="code" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">nnz_count</a> = count;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;}</div>
<div class="ttc" id="classlilc__matrix_html_ab9ee09328b84657630f52631ea8e5eb1"><div class="ttname"><a href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">lilc_matrix::advance_list</a></div><div class="ttdeci">void advance_list(const int &amp;k)</div><div class="ttdoc">Updates A.list for iteration k. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:323</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_acdc8477f4f3893490bbf0b196438fab8"><div class="ttname"><a href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">lil_sparse_matrix::nnz_count</a></div><div class="ttdeci">int nnz_count</div><div class="ttdoc">Number of nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:32</div></div>
<div class="ttc" id="classblock__diag__matrix_html_aa57572352da969e948428ad7521a1ce3"><div class="ttname"><a href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3">block_diag_matrix::off_diagonal</a></div><div class="ttdeci">el_type &amp; off_diagonal(int i)</div><div class="ttdef"><b>Definition:</b> block_diag_matrix.h:111</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlilc__matrix_html_a83c70482c28275881562ee3937b5f591"><div class="ttname"><a href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">lilc_matrix::idx_vector_type</a></div><div class="ttdeci">lil_sparse_matrix&lt; el_type &gt;::idx_vector_type idx_vector_type</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:38</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a1ff3caa5707b4757ef6286017c9ded5e"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e">update</a></div><div class="ttdeci">void update(const int &amp;r, vector&lt; el_type &gt; &amp;work, vector&lt; int &gt; &amp;curr_nnzs, lilc_matrix&lt; el_type &gt; &amp;L, block_diag_matrix&lt; el_type &gt; &amp;D, vector&lt; bool &gt; &amp;in_set)</div><div class="ttdoc">Performs a delayed update of subcolumn A(k:n,r). Result is stored in work vector. Nonzero elements of...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:216</div></div>
<div class="ttc" id="classlilc__matrix_html_a5a4cb5093a935dd9411839c8f54c5a7b"><div class="ttname"><a href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">lilc_matrix::pivotA</a></div><div class="ttdeci">void pivotA(swap_struct&lt; el_type &gt; s, vector&lt; bool &gt; &amp;in_set, const int &amp;k, const int &amp;r)</div><div class="ttdoc">The inplace version of the function above. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_pivot.h:69</div></div>
<div class="ttc" id="classlilc__matrix_html_a2ca57e0c3866ed0cf1f17f6253666ebb"><div class="ttname"><a href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">lilc_matrix::row_first</a></div><div class="ttdeci">std::vector&lt; int &gt; row_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:46</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_af0e67313612267ba689bc7625a691567"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567">unordered_inplace_union</a></div><div class="ttdeci">void unordered_inplace_union(InputContainer &amp;a, InputIterator const &amp;b_start, InputIterator const &amp;b_end, vector&lt; bool &gt; &amp;in_set)</div><div class="ttdoc">Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:137</div></div>
<div class="ttc" id="classblock__diag__matrix_html_aa2f3ffb9d4e198ab18262b702c79cadb"><div class="ttname"><a href="classblock__diag__matrix.html#aa2f3ffb9d4e198ab18262b702c79cadb">block_diag_matrix::resize</a></div><div class="ttdeci">void resize(int n, el_type default_value)</div><div class="ttdoc">Resizes this matrix to an n*n matrix with default_value on the main diagonal. </div><div class="ttdef"><b>Definition:</b> block_diag_matrix.h:68</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classlilc__matrix_html_a177dde39764c88fe4e82b050a5e60303"><div class="ttname"><a href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">lilc_matrix::advance_first</a></div><div class="ttdeci">void advance_first(const int &amp;k)</div><div class="ttdoc">Updates A.first for iteration k. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:313</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_af764d0312eb9f7939ab144b12972bf56"><div class="ttname"><a href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">lil_sparse_matrix::eps</a></div><div class="ttdeci">el_type eps</div><div class="ttdoc">Machine epsilon for el_type. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:33</div></div>
<div class="ttc" id="classlilc__matrix_html_a9c53c4a5816e0e21a167044f07b2ba6aa97c60a3a4e61ee21e3f38a2f950fe293"><div class="ttname"><a href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aa97c60a3a4e61ee21e3f38a2f950fe293">lilc_matrix::pivot_type::ROOK</a></div></div>
<div class="ttc" id="classswap__struct_html"><div class="ttname"><a href="classswap__struct.html">swap_struct</a></div><div class="ttdoc">A structure containing variables used in pivoting a LIL-C matrix. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:6</div></div>
<div class="ttc" id="classlilc__matrix_html_aa5a7b6e31a6c9ebf2ea3a898fe646af6"><div class="ttname"><a href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">lilc_matrix::elt_vector_type</a></div><div class="ttdeci">lil_sparse_matrix&lt; el_type &gt;::elt_vector_type elt_vector_type</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:39</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a281d3bdc2bb15862886008e2ea39a1e2"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2">drop_tol</a></div><div class="ttdeci">void drop_tol(vector&lt; el_type &gt; &amp;v, vector&lt; int &gt; &amp;curr_nnzs, const int &amp;lfil, const double &amp;tol)</div><div class="ttdoc">Performs the dual-dropping criteria outlined in Li & Saad (2005). </div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:166</div></div>
<div class="ttc" id="classlilc__matrix_html_a0e59d373ec514c8cb264da653d36f753"><div class="ttname"><a href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">lilc_matrix::coeff</a></div><div class="ttdeci">virtual el_type coeff(const int &amp;i, const int &amp;j, int offset=0) const </div><div class="ttdoc">Finds the (i,j)th coefficient of the matrix. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:76</div></div>
<div class="ttc" id="classlilc__matrix_html_a36c12de6fccae4ac5a885e8aa60788e9"><div class="ttname"><a href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">lilc_matrix::col_first</a></div><div class="ttdeci">std::vector&lt; int &gt; col_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:47</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a7319334b43609089b10764dcd0df64cb"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a></div><div class="ttdeci">double max(vector&lt; el_type &gt; &amp;v, vector&lt; int &gt; &amp;curr_nnzs, int &amp;r)</div><div class="ttdoc">Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:40</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a40bc09d3b6716e57134eed0aeba49199"><div class="ttname"><a href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">lil_sparse_matrix::nnz</a></div><div class="ttdeci">int nnz() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:58</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac88631204bcf7c9a223fb082a7d0cd3d"><div class="ttname"><a href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">lil_sparse_matrix::n_cols</a></div><div class="ttdeci">int n_cols() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:52</div></div>
<div class="ttc" id="classlilc__matrix_html_a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b"><div class="ttname"><a href="classlilc__matrix.html#a9c53c4a5816e0e21a167044f07b2ba6aaa5c6bb069daaa5e4e9fdd6dee8cf388b">lilc_matrix::pivot_type::BKP</a></div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a9c060e7f9ab18bfcd8386b523f36b0e1"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a></div><div class="ttdeci">void safe_swap(vector&lt; int &gt; &amp;curr_nnzs, const int &amp;k, const int &amp;r)</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:251</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a8cc83364ccef8d296e7dabed833d865c_cgraph.png" border="0" usemap="#classlilc__matrix_a8cc83364ccef8d296e7dabed833d865c_cgraph" alt=""/></div>
<map name="classlilc__matrix_a8cc83364ccef8d296e7dabed833d865c_cgraph" id="classlilc__matrix_a8cc83364ccef8d296e7dabed833d865c_cgraph">
<area shape="rect" id="node2" href="classblock__diag__matrix.html#aa2f3ffb9d4e198ab18262b702c79cadb" title="Resizes this matrix to an n*n matrix with default_value on the main diagonal. " alt="" coords="216,58,359,99"/><area shape="rect" id="node3" href="lilc__matrix__ildl__helpers_8h.html#a1ff3caa5707b4757ef6286017c9ded5e" title="Performs a delayed update of subcolumn A(k:n,r). Result is stored in work vector. Nonzero elements of..." alt="" coords="254,124,321,151"/><area shape="rect" id="node7" href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567" title="Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list..." alt="" coords="597,176,783,203"/><area shape="rect" id="node9" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3" title="block_diag_matrix::\loff_diagonal" alt="" coords="407,173,549,214"/><area shape="rect" id="node10" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index. " alt="" coords="263,289,311,316"/><area shape="rect" id="node11" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1" title="safe_swap" alt="" coords="242,340,333,367"/><area shape="rect" id="node12" href="lilc__matrix__ildl__helpers_8h.html#a281d3bdc2bb15862886008e2ea39a1e2" title="Performs the dual&#45;dropping criteria outlined in Li &amp; Saad (2005). " alt="" coords="250,391,325,417"/><area shape="rect" id="node4" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753" title="Finds the (i,j)th coefficient of the matrix. " alt="" coords="417,5,539,32"/><area shape="rect" id="node5" href="lilc__matrix__ildl__helpers_8h.html#a737792b9fd3b712d9b15578a3f067f3c" title="update_single" alt="" coords="422,56,534,83"/><area shape="rect" id="node8" href="classblock__diag__matrix.html#ad2a00befe5b5c5718e222fa99cbbefd2" title="block_diag_matrix::\lblock_size" alt="" coords="407,107,549,149"/><area shape="rect" id="node6" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa" title="Ensures two the invariants observed by A.first and A.list are held. " alt="" coords="622,49,758,90"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aea5613e9a57231a6991dcf99d6d7b37a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a matrix in matrix market format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be loaded. Must be in matrix market format (.mtx). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;{</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        std::ifstream input(filename.c_str(), std::ios::in);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        <span class="keywordflow">if</span>(!input) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">int</span> maxBuffersize = 2048;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        <span class="keywordtype">char</span> buffer[maxBuffersize];</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="keywordtype">bool</span> readsizes = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <span class="keywordtype">int</span> <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>(-1), <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(-1), n_nzs(-1), i(-1), j(-1);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="keywordtype">int</span> count = 0;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        el_type value; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">while</span>(input.getline(buffer, maxBuffersize))</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                <span class="comment">// skip comments   </span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                <span class="comment">//NOTE An appropriate test should be done on the header to get the symmetry</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                <span class="keywordflow">if</span>(buffer[0]==<span class="charliteral">&#39;%&#39;</span>)</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                </div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                std::stringstream line(buffer);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                <span class="keywordflow">if</span>(!readsizes)</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                        line &gt;&gt; <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a> &gt;&gt; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a> &gt;&gt; n_nzs;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                        <span class="keywordflow">if</span>(<a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a> &gt; 0 &amp;&amp; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a> &gt; 0 &amp;&amp; n_nzs &gt; 0) </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                        {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                                readsizes = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                                </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                                <a class="code" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">resize</a>(<a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                                std::fill(<a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>.begin(), <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>.end(), 0); <span class="comment">//a bit of optimization could be used here since resize sets all elem in first to 1</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                                std::fill(<a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>.begin(), <a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>.end(), 0); <span class="comment">//a bit of optimization could be used here since resize sets all elem in first to 1</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                }</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                { </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                        i = -1;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                        j = -1;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                        <span class="keywordflow">if</span>( <a class="code" href="lilc__matrix__load_8h.html#a28debe718b4595841cc28f2d313aee61">readline</a>(line, <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>, i, j, value) ) </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                        {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].push_back(i);</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j].push_back(value);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                                ++count;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                                </div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                                <span class="keywordflow">if</span> (i != j) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i].push_back(j);</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                </div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                        }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                        <span class="keywordflow">else</span> </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                        std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid read: &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;         </div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                }</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordflow">if</span> (count != n_nzs) std::cout &lt;&lt; <span class="stringliteral">&quot;Expected &quot;</span> &lt;&lt; n_nzs &lt;&lt; <span class="stringliteral">&quot; elems but read &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <a class="code" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">nnz_count</a> = count;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Load succeeded. &quot;</span> &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; was loaded.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        input.close();</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;}</div>
<div class="ttc" id="classlil__sparse__matrix_html_acdc8477f4f3893490bbf0b196438fab8"><div class="ttname"><a href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">lil_sparse_matrix::nnz_count</a></div><div class="ttdeci">int nnz_count</div><div class="ttdoc">Number of nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:32</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlilc__matrix_html_a2ca57e0c3866ed0cf1f17f6253666ebb"><div class="ttname"><a href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">lilc_matrix::row_first</a></div><div class="ttdeci">std::vector&lt; int &gt; row_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:46</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a29e9ea5f7c8a9fca9029a91b39c592e0"><div class="ttname"><a href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">lil_sparse_matrix::n_rows</a></div><div class="ttdeci">int n_rows() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:46</div></div>
<div class="ttc" id="classlilc__matrix_html_aca815e0ac073abb1e6ef888b09f9e795"><div class="ttname"><a href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">lilc_matrix::resize</a></div><div class="ttdeci">void resize(int n_rows, int n_cols)</div><div class="ttdoc">Resizes the matrix. For use in preallocating space before factorization begins. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:115</div></div>
<div class="ttc" id="classlilc__matrix_html_a36c12de6fccae4ac5a885e8aa60788e9"><div class="ttname"><a href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">lilc_matrix::col_first</a></div><div class="ttdeci">std::vector&lt; int &gt; col_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:47</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac88631204bcf7c9a223fb082a7d0cd3d"><div class="ttname"><a href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">lil_sparse_matrix::n_cols</a></div><div class="ttdeci">int n_cols() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:52</div></div>
<div class="ttc" id="lilc__matrix__load_8h_html_a28debe718b4595841cc28f2d313aee61"><div class="ttname"><a href="lilc__matrix__load_8h.html#a28debe718b4595841cc28f2d313aee61">readline</a></div><div class="ttdeci">bool readline(std::stringstream &amp;line, int &amp;n_rows, int &amp;n_cols, int &amp;i, int &amp;j, el_type &amp;value)</div><div class="ttdef"><b>Definition:</b> lilc_matrix_load.h:12</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph.png" border="0" usemap="#classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph" alt=""/></div>
<map name="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph" id="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph">
<area shape="rect" id="node2" href="lilc__matrix__load_8h.html#a28debe718b4595841cc28f2d313aee61" title="readline" alt="" coords="172,5,245,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a00362a639b1e8ec341014c39afaf5e5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_mult</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a matrix-vector product with this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the vector to be multiplied. </td></tr>
    <tr><td class="paramname">y</td><td>a storage vector for the result (must be same size as x). </td></tr>
    <tr><td class="paramname">full_mult</td><td>if true, we assume that only half the matrix is stored and do do operations per element of the matrix to account for the unstored other half. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                                                                                           {</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                y.clear(); y.resize(x.size(), 0);</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>; i++) {</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].size(); k++) {</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                                y[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i][k]] += x[i]*<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][k];</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                                <span class="keywordflow">if</span> (full_mult &amp;&amp; i != m_idx[i][k]) {</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                                        y[i] += x[m_idx[i][k]]*m_x[i][k];</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                                }</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                        }</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                }</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_aab335a46ece471fd0edf52540e24225a"><div class="ttname"><a href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">lil_sparse_matrix::m_n_cols</a></div><div class="ttdeci">int m_n_cols</div><div class="ttdoc">Number of cols in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:31</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad2c9a672941d6b47d3c60f631d21078c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::pivot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a symmetric permutation between row/col k &amp; r of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a struct containing temporary variables needed during pivoting. </td></tr>
    <tr><td class="paramname">in_set</td><td>a bitset needed for unordered unions during pivoting. </td></tr>
    <tr><td class="paramname">L</td><td>the lower triangular factor of A. </td></tr>
    <tr><td class="paramname">k</td><td>index of row/col k. </td></tr>
    <tr><td class="paramname">r</td><td>index of row/col r.</td></tr>
  </table>
  </dd>
</dl>
<p>There are four parts to this pivoting algorithm. For A, due to storing only the lower half, there are three steps to performing a symmetric permutation:</p><ol type="1">
<li>A(k, 1:k) must be swapped with A(r, 1:k) (row-row swap).</li>
<li>A(k:r, k) must be swapped with A(r, k:r) (row-column swap).</li>
<li>A(k:r, k) must be swapped with A(k:r, r) (column-column swap). The steps above are implemented in the pivotA function. <pre class="fragment">For L, since column k and r are not yet formed, there is only one step (a row permutation):
    -#      L(k, 1:k) must be swapped with L(r, 1:k) (row-row swap).</pre> </li>
</ol>
<div class="fragment"><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;{       </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="comment">//initialize temp variables</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        <span class="keywordtype">int</span> i, j, idx, offset;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        <span class="comment">//----------pivot A ----------//</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        this-&gt;<a class="code" href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">pivotA</a>(s, in_set, k, r);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        <span class="comment">//--------end pivot A---------//</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        </div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        <span class="comment">//----------pivot L ----------//</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        s.<a class="code" href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581">swap_clear</a>();</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        <span class="comment">// -------------------- (1) for L ------------------------//</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        <span class="comment">//push back pointers to L(k, i)</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].begin(); it != L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].end(); it++)</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                <span class="keywordflow">for</span> (i = L.<a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>[*it]; i &lt; (<span class="keywordtype">int</span>) L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].size(); i++) {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                        <span class="keywordflow">if</span> (L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it][i] == k) {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9">swapr</a>.push_back(L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].begin() + i);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                        }</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                }</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        }</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="comment">//push back pointers to L(r, i)</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].begin(); it != L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].end(); it++) {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                <span class="keywordflow">for</span> (i = L.<a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>[*it]; i &lt; (<span class="keywordtype">int</span>) L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].size(); i++) {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                        <span class="keywordflow">if</span> (L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it][i] == r) {                             </div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9">swapk</a>.push_back(L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].begin() + i);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                        }</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        }</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="comment">//swap rows k and r</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> vector&lt;idx_it&gt;::iterator it = s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9">swapk</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9">swapk</a>.end(); it++) {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                **it = k;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        }</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> vector&lt;idx_it&gt;::iterator it = s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9">swapr</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9">swapr</a>.end(); it++) {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                **it = r;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <span class="comment">//row swap on row non-zero indices stored in L.list</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].swap(L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r]);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="comment">//--------end pivot L---------//</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;}</div>
<div class="ttc" id="classswap__struct_html_ac67fad73735b183c372ef63b4a9cd581"><div class="ttname"><a href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581">swap_struct::swap_clear</a></div><div class="ttdeci">void swap_clear()</div><div class="ttdoc">Clears all swap vectors (swapk, swapr, all_swaps). </div><div class="ttdef"><b>Definition:</b> swap_struct.h:30</div></div>
<div class="ttc" id="classswap__struct_html_a609dd0d32e04b30b0db6830ab56a8de9"><div class="ttname"><a href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9">swap_struct::swapk</a></div><div class="ttdeci">vector&lt; idx_it &gt; swapk</div><div class="ttdoc">List of indices from row r that will be swapped to row k. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:15</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlilc__matrix_html_a5a4cb5093a935dd9411839c8f54c5a7b"><div class="ttname"><a href="classlilc__matrix.html#a5a4cb5093a935dd9411839c8f54c5a7b">lilc_matrix::pivotA</a></div><div class="ttdeci">void pivotA(swap_struct&lt; el_type &gt; s, vector&lt; bool &gt; &amp;in_set, const int &amp;k, const int &amp;r)</div><div class="ttdoc">The inplace version of the function above. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_pivot.h:69</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classswap__struct_html_a145f164cc7d5b81b259f0fe558faacf9"><div class="ttname"><a href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9">swap_struct::swapr</a></div><div class="ttdeci">vector&lt; idx_it &gt; swapr</div><div class="ttdoc">List of indices from row k that will be swapped to row r. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:16</div></div>
<div class="ttc" id="classlilc__matrix_html_a36c12de6fccae4ac5a885e8aa60788e9"><div class="ttname"><a href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">lilc_matrix::col_first</a></div><div class="ttdeci">std::vector&lt; int &gt; col_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:47</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_ad2c9a672941d6b47d3c60f631d21078c_cgraph.png" border="0" usemap="#classlilc__matrix_ad2c9a672941d6b47d3c60f631d21078c_cgraph" alt=""/></div>
<map name="classlilc__matrix_ad2c9a672941d6b47d3c60f631d21078c_cgraph" id="classlilc__matrix_ad2c9a672941d6b47d3c60f631d21078c_cgraph">
<area shape="rect" id="node2" href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581" title="Clears all swap vectors (swapk, swapr, all_swaps). " alt="" coords="176,5,357,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5a4cb5093a935dd9411839c8f54c5a7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::pivotA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inplace version of the function above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a struct containing temporary variables needed during pivoting. </td></tr>
    <tr><td class="paramname">in_set</td><td>a bitset needed for unordered unions during pivoting. </td></tr>
    <tr><td class="paramname">k</td><td>index of row/col k. </td></tr>
    <tr><td class="paramname">r</td><td>index of row/col r.</td></tr>
  </table>
  </dd>
</dl>
<p>There are three parts to this pivoting algorithm. For A, due to storing only the lower half, there are three steps to performing a symmetric permutation:</p><ol type="1">
<li>A(k, 1:k) must be swapped with A(r, 1:k) (row-row swap).</li>
<li>A(k:r, k) must be swapped with A(r, k:r) (row-column swap).</li>
<li>A(k:r, k) must be swapped with A(k:r, r) (column-column swap). </li>
</ol>
<div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;{       </div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="comment">//initialize temp variables</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        std::pair&lt;idx_it, elt_it&gt; its_k, its_r;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordtype">int</span> i, j, idx, offset;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        </div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="comment">//----------- clear out old variables from last pivot -------------- //</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="comment">//for vectors of primitive types, clear is always constant time regardless of how many elements are in the container.</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        s.<a class="code" href="classswap__struct.html#ad97200ee23cd1f70668d6b4462228343">col_clear</a>();</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        s.<a class="code" href="classswap__struct.html#a9727bf8ea70308977661235c59e3b8da">row_clear</a>();</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="comment">//----------pivot A ----------//</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        s.<a class="code" href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581">swap_clear</a>();</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="comment">//------------- row-row swap (1) for A -------------//</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        </div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="comment">//pushes column indices (which contain non-zero elements) of A(k, 1:k) onto row_r</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].begin() + <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[k]; ++it) {</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                s.<a class="code" href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427">row_r</a>.push_back(*it);</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="comment">//pushes column indices (which contain non-zero elements) of A(r, 1:k) onto row_k</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].begin() + <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r]; ++it) {</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                s.<a class="code" href="classswap__struct.html#a52180e1635646cd4f2dab0209ae62cb9">row_k</a>.push_back(*it);</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        }</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        <span class="comment">//merge these two sets of indices together</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839">all_swaps</a>.assign(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].begin(), <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].begin() + <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[k]);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567">unordered_inplace_union</a>(s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839">all_swaps</a>, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].begin(), <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].begin() + <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r], in_set);</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        </div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="comment">//do row swaps in A (i.e. swap A(k, 1:k) with A(r, 1:k))</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839">all_swaps</a>.begin(), end = s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839">all_swaps</a>.end(); it != end; ++it) {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a>(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it], k, r);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        }</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839">all_swaps</a>.clear();</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        <span class="comment">//----------------------------------------------------//</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        </div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="comment">//---------------------- (2) and (3) for A --------------------------//</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        </div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="comment">//after sym. perm, a_rr will be swapped to a_kk, so we put a_rr as first</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="comment">//elem of col k if its non-zero. this also means that we ensure the first</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="comment">//elem of col k is the diagonal element if it exists.</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        el_type elem = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a>(r, r);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keywordflow">if</span> (abs(elem) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>){</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71">col_k_nnzs</a>.push_back(k);</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                s.<a class="code" href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352">col_k</a>.push_back(elem);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        }</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        </div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="comment">//same as above, put a_kk in new col r if it exists.</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        elem = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a>(k, k);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keywordflow">if</span> (abs(elem) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>){</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                s.<a class="code" href="classswap__struct.html#a8d4e30cd03fc142b81a332db04edc244">col_r_nnzs</a>.push_back(r);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                s.<a class="code" href="classswap__struct.html#a3803a938141694098700de00d5cb6a7d">col_r</a>.push_back(elem);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        }</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        </div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="comment">//first[r] should have # of nnz of A(r, 0:k-1)</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">for</span> (i = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r]; i &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].size(); i++) {</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                j = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r][i];</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">coeffRef</a>(r, j, its_k)) {</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                        <span class="keywordflow">if</span> (j == k) {</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                                s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71">col_k_nnzs</a>.push_back(r); <span class="comment">//A(r, k) is fixed upon permutation so its index stays r</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                                s.<a class="code" href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427">row_r</a>.push_back(k);</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                                s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71">col_k_nnzs</a>.push_back(j); <span class="comment">//place A(r, j) (where k &lt; j &lt; r) into A(j, k)</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                        }</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                        s.<a class="code" href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352">col_k</a>.push_back(*its_k.second);</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                        </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                        <span class="comment">//delete A(r,j) from A.</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                        *its_k.first = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].back();</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                        *its_k.second = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j].back();</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                        </div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].pop_back();</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j].pop_back();</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                }</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        }</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].size() &gt; 0) {</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        </div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                <span class="comment">//place A(r:n, r) into A(r:n, k). since we already took care of A(r,r) above,</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                <span class="comment">//we need to offset by 1 if necessary.</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <a class="code" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a>(r, r, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r], <span class="keyword">false</span>);</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                offset = (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r][0] == r ? 1 : 0);</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                std::copy(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r].begin()+offset, <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r].end(), std::back_inserter(s.<a class="code" href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352">col_k</a>));</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                std::copy(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin()+offset, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end(), std::back_inserter(s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71">col_k_nnzs</a>));</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin() + offset; it != <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end(); it++) {</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                        <span class="comment">//for each non-zero row index in the rth column, find a pointer to it in list</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                        <span class="comment">//these pointers will be used to perform column swaps on list</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                        <span class="keywordflow">for</span> (i = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[*it]; i &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].size(); i++) {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it][i] == r) {</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                                        s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9">swapk</a>.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].begin() + i);</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                                }</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                        }</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                }</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        }</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="comment">//swap A(k:r, k) with A(r, k:r)</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].size() &gt; 0) {</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                </div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                <span class="comment">//since we already took care of A(k,k), we need an offset of 1 if necessary</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <a class="code" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a>(k, k, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k], <span class="keyword">false</span>);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                offset = (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][0] == k ? 1 : 0);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                <span class="keywordflow">for</span> (i = offset; i &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].size(); i++) {</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                        idx = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i];</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                        </div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                        <span class="comment">//if idx &lt; r, we are in (2) (row-col swap) otherwise we are in (3) (col-col swap)</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                        <span class="keywordflow">if</span> (idx &lt; r) {</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                        </div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                                <span class="comment">//swap A(i, k) with A(r, i) where k &lt; i &lt; r.</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[idx].push_back(r);        </div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[idx].push_back(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i]);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                                </div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                                <span class="comment">//we also have to ensure that list is updated by popping off old entries</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                                <span class="comment">//that were meant for the A(i, k)&#39;s before they were swapped.</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                                <a class="code" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a>(idx, k, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[idx], <span class="keyword">true</span>);</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                                std::swap(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[idx][<a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[idx]], <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[idx][<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[idx].size() - 1]);</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[idx].pop_back();</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                                </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                                <span class="comment">//push back new elements on row_r</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                                s.<a class="code" href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427">row_r</a>.push_back(idx);</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                                </div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (idx &gt; r) {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                        </div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                                <span class="comment">//swap A(i, k) with A(i, r) where r &lt; i.</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                                s.<a class="code" href="classswap__struct.html#a3803a938141694098700de00d5cb6a7d">col_r</a>.push_back(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i]);</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                                s.<a class="code" href="classswap__struct.html#a8d4e30cd03fc142b81a332db04edc244">col_r_nnzs</a>.push_back(idx);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                                </div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                                <span class="comment">//for each non-zero row index in the kth column, find a pointer to it in list</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                                <span class="comment">//these pointers will be used to perform column swaps on list</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                                <span class="keywordflow">for</span> (j = <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[idx]; j &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[idx].size(); j++) {</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                                        <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[idx][j] == k) {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                                                s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9">swapr</a>.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[idx].begin() + j);</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                                                <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                                        }</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                                }</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                        }</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                }</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="comment">//swap all A(i, k) with A(i, r) in list.</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> vector&lt;idx_it&gt;::iterator it = s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9">swapk</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9">swapk</a>.end(); it++) {</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                **it = k;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        }</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">typename</span> vector&lt;idx_it&gt;::iterator it = s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9">swapr</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9">swapr</a>.end(); it++) {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                **it = r;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        }</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        <span class="comment">//add new entries for new col k into list</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71">col_k_nnzs</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71">col_k_nnzs</a>.end(); it++) {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                <span class="keywordflow">if</span> ((*it &gt; k) &amp;&amp; (*it &lt; r)) {</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[*it].push_back(k);</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                }</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        }</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        </div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="comment">//set the kth col</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].swap(s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71">col_k_nnzs</a>);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k].swap(s.<a class="code" href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352">col_k</a>);</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        </div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="comment">//set the rth col</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].swap(s.<a class="code" href="classswap__struct.html#a8d4e30cd03fc142b81a332db04edc244">col_r_nnzs</a>);</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r].swap(s.<a class="code" href="classswap__struct.html#a3803a938141694098700de00d5cb6a7d">col_r</a>);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        </div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="comment">//set the kth row and rth row</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[k].swap(s.<a class="code" href="classswap__struct.html#a52180e1635646cd4f2dab0209ae62cb9">row_k</a>);</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[r].swap(s.<a class="code" href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427">row_r</a>);</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="comment">//row swaps for first</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        std::swap(<a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[k], <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>[r]);</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <span class="comment">//--------end pivot A---------//</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div>
<div class="ttc" id="classswap__struct_html_ad97200ee23cd1f70668d6b4462228343"><div class="ttname"><a href="classswap__struct.html#ad97200ee23cd1f70668d6b4462228343">swap_struct::col_clear</a></div><div class="ttdeci">void col_clear()</div><div class="ttdoc">Clears all col vectors (col_k, col_r, col_k_nnzs, col_r_nnzs). </div><div class="ttdef"><b>Definition:</b> swap_struct.h:38</div></div>
<div class="ttc" id="classswap__struct_html_ac67fad73735b183c372ef63b4a9cd581"><div class="ttname"><a href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581">swap_struct::swap_clear</a></div><div class="ttdeci">void swap_clear()</div><div class="ttdoc">Clears all swap vectors (swapk, swapr, all_swaps). </div><div class="ttdef"><b>Definition:</b> swap_struct.h:30</div></div>
<div class="ttc" id="classswap__struct_html_a609dd0d32e04b30b0db6830ab56a8de9"><div class="ttname"><a href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9">swap_struct::swapk</a></div><div class="ttdeci">vector&lt; idx_it &gt; swapk</div><div class="ttdoc">List of indices from row r that will be swapped to row k. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:15</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classswap__struct_html_a7a9e67b4e6e1b9d1e6d2aefef3edda71"><div class="ttname"><a href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71">swap_struct::col_k_nnzs</a></div><div class="ttdeci">idx_vector_type col_k_nnzs</div><div class="ttdoc">Row indices of non-zeros in the new column k. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:19</div></div>
<div class="ttc" id="classswap__struct_html_af5461fcf0c0808ef0ef5ac9c6e212839"><div class="ttname"><a href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839">swap_struct::all_swaps</a></div><div class="ttdeci">idx_vector_type all_swaps</div><div class="ttdoc">Column indices of all swaps done in swapk and swapr. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:18</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlilc__matrix_html_a2ca57e0c3866ed0cf1f17f6253666ebb"><div class="ttname"><a href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">lilc_matrix::row_first</a></div><div class="ttdeci">std::vector&lt; int &gt; row_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:46</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_af0e67313612267ba689bc7625a691567"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567">unordered_inplace_union</a></div><div class="ttdeci">void unordered_inplace_union(InputContainer &amp;a, InputIterator const &amp;b_start, InputIterator const &amp;b_end, vector&lt; bool &gt; &amp;in_set)</div><div class="ttdoc">Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:137</div></div>
<div class="ttc" id="classlilc__matrix_html_a327c165f0c90cd362dd14fc6421ebadd"><div class="ttname"><a href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">lilc_matrix::coeffRef</a></div><div class="ttdeci">bool coeffRef(const int &amp;i, const int &amp;j, std::pair&lt; idx_it, elt_it &gt; &amp;its)</div><div class="ttdoc">Finds the index/value pointers to (i,j)th coefficient of the matrix. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:98</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_af764d0312eb9f7939ab144b12972bf56"><div class="ttname"><a href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">lil_sparse_matrix::eps</a></div><div class="ttdeci">el_type eps</div><div class="ttdoc">Machine epsilon for el_type. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:33</div></div>
<div class="ttc" id="classswap__struct_html_a9727bf8ea70308977661235c59e3b8da"><div class="ttname"><a href="classswap__struct.html#a9727bf8ea70308977661235c59e3b8da">swap_struct::row_clear</a></div><div class="ttdeci">void row_clear()</div><div class="ttdoc">Clears all row vectors (row_k, row_r). </div><div class="ttdef"><b>Definition:</b> swap_struct.h:47</div></div>
<div class="ttc" id="classswap__struct_html_a145f164cc7d5b81b259f0fe558faacf9"><div class="ttname"><a href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9">swap_struct::swapr</a></div><div class="ttdeci">vector&lt; idx_it &gt; swapr</div><div class="ttdoc">List of indices from row k that will be swapped to row r. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:16</div></div>
<div class="ttc" id="classswap__struct_html_a8d4e30cd03fc142b81a332db04edc244"><div class="ttname"><a href="classswap__struct.html#a8d4e30cd03fc142b81a332db04edc244">swap_struct::col_r_nnzs</a></div><div class="ttdeci">idx_vector_type col_r_nnzs</div><div class="ttdoc">Row indices of non-zeros in the new column r. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:20</div></div>
<div class="ttc" id="classswap__struct_html_a3803a938141694098700de00d5cb6a7d"><div class="ttname"><a href="classswap__struct.html#a3803a938141694098700de00d5cb6a7d">swap_struct::col_r</a></div><div class="ttdeci">elt_vector_type col_r</div><div class="ttdoc">Non-zero values in the new column r (order dependent on col_r_nnzs). </div><div class="ttdef"><b>Definition:</b> swap_struct.h:23</div></div>
<div class="ttc" id="classlilc__matrix_html_a0e59d373ec514c8cb264da653d36f753"><div class="ttname"><a href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">lilc_matrix::coeff</a></div><div class="ttdeci">virtual el_type coeff(const int &amp;i, const int &amp;j, int offset=0) const </div><div class="ttdoc">Finds the (i,j)th coefficient of the matrix. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:76</div></div>
<div class="ttc" id="classlilc__matrix_html_aa1d3045545357a8f33955a87dc55f3aa"><div class="ttname"><a href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">lilc_matrix::ensure_invariant</a></div><div class="ttdeci">void ensure_invariant(const int &amp;j, const int &amp;k, Container &amp;con, bool update_list=false)</div><div class="ttdoc">Ensures two the invariants observed by A.first and A.list are held. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:285</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
<div class="ttc" id="classswap__struct_html_a3b6ad04f7393ddd5c8b130e33208d427"><div class="ttname"><a href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427">swap_struct::row_r</a></div><div class="ttdeci">idx_vector_type row_r</div><div class="ttdoc">Column indices of non-zeros in the new row r. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:26</div></div>
<div class="ttc" id="classswap__struct_html_a52180e1635646cd4f2dab0209ae62cb9"><div class="ttname"><a href="classswap__struct.html#a52180e1635646cd4f2dab0209ae62cb9">swap_struct::row_k</a></div><div class="ttdeci">idx_vector_type row_k</div><div class="ttdoc">Column indices of non-zeros in the new row k. </div><div class="ttdef"><b>Definition:</b> swap_struct.h:25</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a9c060e7f9ab18bfcd8386b523f36b0e1"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1">safe_swap</a></div><div class="ttdeci">void safe_swap(vector&lt; int &gt; &amp;curr_nnzs, const int &amp;k, const int &amp;r)</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:251</div></div>
<div class="ttc" id="classswap__struct_html_a39ab00a67015a67c375b620f54cc6352"><div class="ttname"><a href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352">swap_struct::col_k</a></div><div class="ttdeci">elt_vector_type col_k</div><div class="ttdoc">Non-zero values in the new column k (order dependent on col_k_nnzs). </div><div class="ttdef"><b>Definition:</b> swap_struct.h:22</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a5a4cb5093a935dd9411839c8f54c5a7b_cgraph.png" border="0" usemap="#classlilc__matrix_a5a4cb5093a935dd9411839c8f54c5a7b_cgraph" alt=""/></div>
<map name="classlilc__matrix_a5a4cb5093a935dd9411839c8f54c5a7b_cgraph" id="classlilc__matrix_a5a4cb5093a935dd9411839c8f54c5a7b_cgraph">
<area shape="rect" id="node2" href="classswap__struct.html#ad97200ee23cd1f70668d6b4462228343" title="Clears all col vectors (col_k, col_r, col_k_nnzs, col_r_nnzs). " alt="" coords="196,5,363,32"/><area shape="rect" id="node3" href="classswap__struct.html#a9727bf8ea70308977661235c59e3b8da" title="Clears all row vectors (row_k, row_r). " alt="" coords="194,56,365,83"/><area shape="rect" id="node4" href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581" title="Clears all swap vectors (swapk, swapr, all_swaps). " alt="" coords="189,107,370,133"/><area shape="rect" id="node5" href="lilc__matrix__ildl__helpers_8h.html#af0e67313612267ba689bc7625a691567" title="Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list..." alt="" coords="187,157,372,184"/><area shape="rect" id="node6" href="lilc__matrix__ildl__helpers_8h.html#a9c060e7f9ab18bfcd8386b523f36b0e1" title="safe_swap" alt="" coords="234,208,325,235"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aca815e0ac073abb1e6ef888b09f9e795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the matrix. For use in preallocating space before factorization begins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_rows</td><td>the number of rows in the resized matrix. </td></tr>
    <tr><td class="paramname">n_cols</td><td>the number of cols in the resized matrix. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9">m_n_rows</a> = <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a> = <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                </div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                </div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                <a class="code" href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>, 1);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                <a class="code" href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>, 1);</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                </div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;                <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>, 1);</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        }</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlilc__matrix_html_afc4659265addfeab376ffaa8f54ed596"><div class="ttname"><a href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">lilc_matrix::S</a></div><div class="ttdeci">block_diag_matrix&lt; el_type &gt; S</div><div class="ttdoc">A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:49</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_aab335a46ece471fd0edf52540e24225a"><div class="ttname"><a href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">lil_sparse_matrix::m_n_cols</a></div><div class="ttdeci">int m_n_cols</div><div class="ttdoc">Number of cols in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:31</div></div>
<div class="ttc" id="classlilc__matrix_html_a2ca57e0c3866ed0cf1f17f6253666ebb"><div class="ttname"><a href="classlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">lilc_matrix::row_first</a></div><div class="ttdeci">std::vector&lt; int &gt; row_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:46</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a29e9ea5f7c8a9fca9029a91b39c592e0"><div class="ttname"><a href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">lil_sparse_matrix::n_rows</a></div><div class="ttdeci">int n_rows() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:46</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a6eac075dab519f837ae660c9ef933eb9"><div class="ttname"><a href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9">lil_sparse_matrix::m_n_rows</a></div><div class="ttdeci">int m_n_rows</div><div class="ttdoc">Number of rows in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:28</div></div>
<div class="ttc" id="classlilc__matrix_html_a36c12de6fccae4ac5a885e8aa60788e9"><div class="ttname"><a href="classlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">lilc_matrix::col_first</a></div><div class="ttdeci">std::vector&lt; int &gt; col_first</div><div class="ttdoc">On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:47</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac88631204bcf7c9a223fb082a7d0cd3d"><div class="ttname"><a href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">lil_sparse_matrix::n_cols</a></div><div class="ttdeci">int n_cols() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:52</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph.png" border="0" usemap="#classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph" alt=""/></div>
<map name="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph" id="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph">
<area shape="rect" id="node2" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0" title="lil_sparse_matrix::\ln_rows" alt="" coords="187,5,323,47"/><area shape="rect" id="node3" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d" title="lil_sparse_matrix::\ln_cols" alt="" coords="187,71,323,112"/><area shape="rect" id="node4" href="classblock__diag__matrix.html#aa2f3ffb9d4e198ab18262b702c79cadb" title="Resizes this matrix to an n*n matrix with default_value on the main diagonal. " alt="" coords="184,136,327,177"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2b0161d36019e1abac41b6119b8fa288"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::save </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sym</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a matrix in matrix market format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be saved. All matrices saved are in matrix market format (.mtx). </td></tr>
    <tr><td class="paramname">sym</td><td>flags whether the matrix is symmetric or not. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;{</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        std::ofstream out(filename.c_str(), std::ios::out | std::ios::binary);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        <span class="keywordflow">if</span>(!out)</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        out.flags(std::ios_base::scientific);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        out.precision(16);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        std::string header; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        <a class="code" href="lilc__matrix__save_8h.html#abea199c89e226136ca0039f1dfcd133f">put_header</a>(header, sym); </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        out &lt;&lt; header &lt;&lt; std::endl; </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        out &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(); i++) {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].size(); j++) {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                        out &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i][j]+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][j] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                }</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        }</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        out.close();</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;}</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a29e9ea5f7c8a9fca9029a91b39c592e0"><div class="ttname"><a href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">lil_sparse_matrix::n_rows</a></div><div class="ttdeci">int n_rows() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:46</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a40bc09d3b6716e57134eed0aeba49199"><div class="ttname"><a href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">lil_sparse_matrix::nnz</a></div><div class="ttdeci">int nnz() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:58</div></div>
<div class="ttc" id="lilc__matrix__save_8h_html_abea199c89e226136ca0039f1dfcd133f"><div class="ttname"><a href="lilc__matrix__save_8h.html#abea199c89e226136ca0039f1dfcd133f">put_header</a></div><div class="ttdeci">void put_header(std::string &amp;header, bool sym=false)</div><div class="ttdef"><b>Definition:</b> lilc_matrix_save.h:5</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac88631204bcf7c9a223fb082a7d0cd3d"><div class="ttname"><a href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">lil_sparse_matrix::n_cols</a></div><div class="ttdeci">int n_cols() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:52</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a2b0161d36019e1abac41b6119b8fa288_cgraph.png" border="0" usemap="#classlilc__matrix_a2b0161d36019e1abac41b6119b8fa288_cgraph" alt=""/></div>
<map name="classlilc__matrix_a2b0161d36019e1abac41b6119b8fa288_cgraph" id="classlilc__matrix_a2b0161d36019e1abac41b6119b8fa288_cgraph">
<area shape="rect" id="node2" href="lilc__matrix__save_8h.html#abea199c89e226136ca0039f1dfcd133f" title="put_header" alt="" coords="176,5,271,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="add59bf538bd6b36c7d42ec879bad4da8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_amd </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Approximate Minimum Degree ordering of the matrix A (stored in perm). </p>
<p>A detailed description of this function as well as all its subfunctions can be found in "An Approximate Minimum Dgree Algorithm" by Davis, Amestoy, and Duff (1981). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>An empty permutation vector (filled on function completion). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                                                             {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keyword">using</span> std::sqrt;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <span class="keyword">using</span> std::min;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        <span class="keyword">using</span> <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">std::max</a>;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordtype">int</span> d, dk, dext, lemax = 0, e, elenk, eln, i, j, k, k1,</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        k2, k3, jlast, ln, dense, nzmax, mindeg = 0, nvi, nvj, nvk, mark, wnvi,</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        ok, nel = 0, p, p1, p2, p3, p4, pj, pk, pk1, pk2, pn, q, t;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordtype">int</span> n = this-&gt;<a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>();</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        dense = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a>(16, <span class="keywordtype">int</span>(10 * sqrt(<span class="keywordtype">double</span>(n))));   <span class="comment">/* find dense threshold */</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        dense = min(n-2, dense);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        perm.resize(n);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keywordtype">int</span>* W       = <span class="keyword">new</span> <span class="keywordtype">int</span>[8*(n+1)]; <span class="comment">/* get workspace */</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordtype">int</span>* len     = W;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        <span class="keywordtype">int</span>* nv      = W +   (n+1);</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordtype">int</span>* next    = W + 2*(n+1);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        <span class="keywordtype">int</span>* head    = W + 3*(n+1);</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        <span class="keywordtype">int</span>* elen    = W + 4*(n+1);</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        <span class="keywordtype">int</span>* degree  = W + 5*(n+1);</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        <span class="keywordtype">int</span>* w       = W + 6*(n+1);</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        <span class="keywordtype">int</span>* hhead   = W + 7*(n+1);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordtype">int</span>* temp_perm = <span class="keyword">new</span> <span class="keywordtype">int</span>[n+1];</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="keywordtype">int</span>* last          = temp_perm;  <span class="comment">//using temp_perms storage space as workspace for last</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="comment">/* --- Initialize quotient graph ---------------------------------------- */</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        <span class="keywordtype">int</span> cnz = this-&gt;<a class="code" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a>();</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        t = 3*cnz + 3*cnz/5 + 2*n;                 <span class="comment">/* add elbow room to C */</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordtype">int</span>* Cp = <span class="keyword">new</span> <span class="keywordtype">int</span>[n+1];</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="keywordtype">int</span>* Ci = <span class="keyword">new</span> <span class="keywordtype">int</span>[t];</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordtype">int</span> cnt = 0;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        Cp[0] = 0;</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i].size(); j++) {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                        Ci[cnt++] = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i][j];</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                }</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].size(); j++) {</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                        Ci[cnt++] = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i][j];</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;                }</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;                Cp[i+1] = cnt;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        }</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        cnz = cnt;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordflow">for</span>(k = 0; k &lt; n; k++)</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                len[k] = Cp[k+1] - Cp[k];</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        len[n] = 0;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        nzmax = t;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="keywordflow">for</span>(i = 0; i &lt;= n; i++)</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        {</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                head[i]   = -1;                     <span class="comment">// degree list i is empty</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                last[i]   = -1;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                next[i]   = -1;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                hhead[i]  = -1;                     <span class="comment">// hash list i is empty </span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                nv[i]     = 1;                      <span class="comment">// node i is just one node</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                w[i]      = 1;                      <span class="comment">// node i is alive</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                elen[i]   = 0;                      <span class="comment">// Ek of node i is empty</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                degree[i] = len[i];                 <span class="comment">// degree of node i</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        }</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        mark = <a class="code" href="namespaceamd.html#a964ea0a8fe5f1a327fc93878ff150923">amd::wclear</a>(0, 0, w, n);         <span class="comment">/* clear w */</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        elen[n] = -2;                         <span class="comment">/* n is a dead element */</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        Cp[n] = -1;                           <span class="comment">/* n is a root of assembly tree */</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        w[n] = 0;                             <span class="comment">/* n is a dead element */</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <span class="comment">/* --- Initialize degree lists ------------------------------------------ */</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">for</span>(i = 0; i &lt; n; i++)</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                d = degree[i];</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                <span class="keywordflow">if</span>(d == 0)                         <span class="comment">/* node i is empty */</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                {</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                        elen[i] = -2;                 <span class="comment">/* element i is dead */</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                        nel++;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                        Cp[i] = -1;                   <span class="comment">/* i is a root of assembly tree */</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                        w[i] = 0;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                }</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(d &gt; dense)                 <span class="comment">/* node i is dense */</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                {</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                        nv[i] = 0;                    <span class="comment">/* absorb i into element n */</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                        elen[i] = -1;                 <span class="comment">/* node i is dead */</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                        nel++;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                        Cp[i] = <a class="code" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a> (n);</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                        nv[n]++;</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                }</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                        <span class="keywordflow">if</span>(head[d] != -1) last[head[d]] = i;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                        next[i] = head[d];           <span class="comment">/* put node i in degree list d */</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                        head[d] = i;</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                }</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        }</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">while</span> (nel &lt; n)                         <span class="comment">/* while (selecting pivots) do */</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                <span class="comment">/* --- Select node of minimum approximate degree -------------------- */</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                <span class="keywordflow">for</span>(k = -1; mindeg &lt; n &amp;&amp; (k = head[mindeg]) == -1; mindeg++) {}</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                <span class="keywordflow">if</span>(next[k] != -1) last[next[k]] = -1;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;                head[mindeg] = next[k];          <span class="comment">/* remove k from degree list */</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                elenk = elen[k];                  <span class="comment">/* elenk = |Ek| */</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                nvk = nv[k];                      <span class="comment">/* # of nodes k represents */</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                nel += nvk;                        <span class="comment">/* nv[k] nodes of A eliminated */</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                </div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                <span class="comment">/* --- Garbage collection ------------------------------------------- */</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                <span class="keywordflow">if</span>(elenk &gt; 0 &amp;&amp; cnz + mindeg &gt;= nzmax)</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                {</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                        <span class="keywordflow">for</span>(j = 0; j &lt; n; j++)</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;                        {</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                                <span class="keywordflow">if</span>((p = Cp[j]) &gt;= 0)      <span class="comment">/* j is a live node or element */</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                                {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                                        Cp[j] = Ci[p];          <span class="comment">/* save first entry of object */</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                                        Ci[p] = <a class="code" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a> (j);    <span class="comment">/* first entry is now amd::amd_flip(j) */</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                                }</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                        }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                        <span class="keywordflow">for</span>(q = 0, p = 0; p &lt; cnz; ) <span class="comment">/* scan all of memory */</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                        {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                                <span class="keywordflow">if</span>((j = <a class="code" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a> (Ci[p++])) &gt;= 0)  <span class="comment">/* found object j */</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;                                {</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;                                        Ci[q] = Cp[j];       <span class="comment">/* restore first entry of object */</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                                        Cp[j] = q++;          <span class="comment">/* new pointer to object j */</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                                        <span class="keywordflow">for</span>(k3 = 0; k3 &lt; len[j]-1; k3++) Ci[q++] = Ci[p++];</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                                }</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;                        }</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                        cnz = q;                       <span class="comment">/* Ci[cnz...nzmax-1] now free */</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                }</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                </div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                <span class="comment">/* --- Construct new element ---------------------------------------- */</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                dk = 0;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;                nv[k] = -nvk;                     <span class="comment">/* flag k as in Lk */</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;                p = Cp[k];</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                pk1 = (elenk == 0) ? p : cnz;      <span class="comment">/* do in place if elen[k] == 0 */</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                pk2 = pk1;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                <span class="keywordflow">for</span>(k1 = 1; k1 &lt;= elenk + 1; k1++)</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                {</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                        <span class="keywordflow">if</span>(k1 &gt; elenk)</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;                        {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                                e = k;                     <span class="comment">/* search the nodes in k */</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                                pj = p;                    <span class="comment">/* list of nodes starts at Ci[pj]*/</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                                ln = len[k] - elenk;      <span class="comment">/* length of list of nodes in k */</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                        }</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                        {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                                e = Ci[p++];              <span class="comment">/* search the nodes in e */</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                                pj = Cp[e];</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                                ln = len[e];              <span class="comment">/* length of list of nodes in e */</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                        }</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                        <span class="keywordflow">for</span>(k2 = 1; k2 &lt;= ln; k2++)</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                        {</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                                i = Ci[pj++];</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                                <span class="keywordflow">if</span>((nvi = nv[i]) &lt;= 0) <span class="keywordflow">continue</span>; <span class="comment">/* node i dead, or seen */</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                                dk += nvi;                 <span class="comment">/* degree[Lk] += size of node i */</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                                nv[i] = -nvi;             <span class="comment">/* negate nv[i] to denote i in Lk*/</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                                Ci[pk2++] = i;            <span class="comment">/* place i in Lk */</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                                <span class="keywordflow">if</span>(next[i] != -1) last[next[i]] = last[i];</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                                <span class="keywordflow">if</span>(last[i] != -1)         <span class="comment">/* remove i from degree list */</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                                {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                                        next[last[i]] = next[i];</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                                }</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;                                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                                {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                                        head[degree[i]] = next[i];</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                                }</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                        }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                        <span class="keywordflow">if</span>(e != k)</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;                        {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                                Cp[e] = <a class="code" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a> (k);      <span class="comment">/* absorb e into k */</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                                w[e] = 0;                 <span class="comment">/* e is now a dead element */</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                        }</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                }</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                <span class="keywordflow">if</span>(elenk != 0) cnz = pk2;         <span class="comment">/* Ci[cnz...nzmax] is free */</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;                degree[k] = dk;                   <span class="comment">/* external degree of k - |Lk\i| */</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;                Cp[k] = pk1;                      <span class="comment">/* element k is in Ci[pk1..pk2-1] */</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                len[k] = pk2 - pk1;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                elen[k] = -2;                     <span class="comment">/* k is now an element */</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                </div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                <span class="comment">/* --- Find set differences ----------------------------------------- */</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;                mark = <a class="code" href="namespaceamd.html#a964ea0a8fe5f1a327fc93878ff150923">amd::wclear</a>(mark, lemax, w, n);  <span class="comment">/* clear w if necessary */</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                <span class="keywordflow">for</span>(pk = pk1; pk &lt; pk2; pk++)    <span class="comment">/* scan 1: find |Le\Lk| */</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                {</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                        i = Ci[pk];</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                        <span class="keywordflow">if</span>((eln = elen[i]) &lt;= 0) <span class="keywordflow">continue</span>;<span class="comment">/* skip if elen[i] empty */</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                        nvi = -nv[i];                      <span class="comment">/* nv[i] was negated */</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                        wnvi = mark - nvi;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                        <span class="keywordflow">for</span>(p = Cp[i]; p &lt;= Cp[i] + eln - 1; p++)  <span class="comment">/* scan Ei */</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                        {</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                                e = Ci[p];</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                                <span class="keywordflow">if</span>(w[e] &gt;= mark)</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                                {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                                        w[e] -= nvi;          <span class="comment">/* decrement |Le\Lk| */</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                                }</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(w[e] != 0)        <span class="comment">/* ensure e is a live element */</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                                {</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                                        w[e] = degree[e] + wnvi; <span class="comment">/* 1st time e seen in scan 1 */</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                                }</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                        }</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                }</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                </div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                <span class="comment">/* --- Degree update ------------------------------------------------ */</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                <span class="keywordflow">for</span>(pk = pk1; pk &lt; pk2; pk++)    <span class="comment">/* scan2: degree update */</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                {</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                        i = Ci[pk];                   <span class="comment">/* consider node i in Lk */</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                        p1 = Cp[i];</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                        p2 = p1 + elen[i] - 1;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                        pn = p1;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                        <span class="keywordflow">for</span>(h = 0, d = 0, p = p1; p &lt;= p2; p++)    <span class="comment">/* scan Ei */</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                        {</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                                e = Ci[p];</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                                <span class="keywordflow">if</span>(w[e] != 0)             <span class="comment">/* e is an unabsorbed element */</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                                {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                                        dext = w[e] - mark;   <span class="comment">/* dext = |Le\Lk| */</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                                        <span class="keywordflow">if</span>(dext &gt; 0)</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                                        {</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                                                d += dext;         <span class="comment">/* sum up the set differences */</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                                                Ci[pn++] = e;     <span class="comment">/* keep e in Ei */</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                                                h += e;            <span class="comment">/* compute the hash of node i */</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                                        }</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                                        {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                                                Cp[e] = <a class="code" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a> (k);  <span class="comment">/* aggressive absorb. e-&gt;k */</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                                                w[e] = 0;             <span class="comment">/* e is a dead element */</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;                                        }</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                                }</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                        }</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                        elen[i] = pn - p1 + 1;        <span class="comment">/* elen[i] = |Ei| */</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                        p3 = pn;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                        p4 = p1 + len[i];</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                        <span class="keywordflow">for</span>(p = p2 + 1; p &lt; p4; p++) <span class="comment">/* prune edges in Ai */</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                        {</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                                j = Ci[p];</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                                <span class="keywordflow">if</span>((nvj = nv[j]) &lt;= 0) <span class="keywordflow">continue</span>; <span class="comment">/* node j dead or in Lk */</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                                d += nvj;                  <span class="comment">/* degree(i) += |j| */</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                                Ci[pn++] = j;             <span class="comment">/* place j in node list of i */</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                                h += j;                    <span class="comment">/* compute hash for node i */</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                        }</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                        <span class="keywordflow">if</span>(d == 0)                     <span class="comment">/* check for mass elimination */</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                        {</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                                Cp[i] = <a class="code" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a> (k);      <span class="comment">/* absorb i into k */</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                                nvi = -nv[i];</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                                dk -= nvi;                 <span class="comment">/* |Lk| -= |i| */</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                                nvk += nvi;                <span class="comment">/* |k| += nv[i] */</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                                nel += nvi;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                                nv[i] = 0;</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                                elen[i] = -1;             <span class="comment">/* node i is dead */</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                        }</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                        {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                                degree[i] = std::min(degree[i], d);   <span class="comment">/* update degree(i) */</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                                Ci[pn] = Ci[p3];         <span class="comment">/* move first node to end */</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                                Ci[p3] = Ci[p1];         <span class="comment">/* move 1st el. to end of Ei */</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                                Ci[p1] = k;               <span class="comment">/* add k as 1st element in of Ei */</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                                len[i] = pn - p1 + 1;     <span class="comment">/* new len of adj. list of node i */</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                                h %= n;                    <span class="comment">/* finalize hash of i */</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                                next[i] = hhead[h];      <span class="comment">/* place i in hash bucket */</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                                hhead[h] = i;</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                                last[i] = h;              <span class="comment">/* save hash of i in last[i] */</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                        }</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                }                                   <span class="comment">/* scan2 is done */</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                degree[k] = dk;                   <span class="comment">/* finalize |Lk| */</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                lemax = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">std::max</a>(lemax, dk);</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                mark = <a class="code" href="namespaceamd.html#a964ea0a8fe5f1a327fc93878ff150923">amd::wclear</a>(mark+lemax, lemax, w, n);    <span class="comment">/* clear w */</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                </div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                <span class="comment">/* --- Supernode detection ------------------------------------------ */</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                <span class="keywordflow">for</span>(pk = pk1; pk &lt; pk2; pk++)</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                        i = Ci[pk];</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                        <span class="keywordflow">if</span>(nv[i] &gt;= 0) <span class="keywordflow">continue</span>;         <span class="comment">/* skip if i is dead */</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                        h = last[i];                      <span class="comment">/* scan hash bucket of node i */</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                        i = hhead[h];</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                        hhead[h] = -1;                    <span class="comment">/* hash bucket will be empty */</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                        <span class="keywordflow">for</span>(; i != -1 &amp;&amp; next[i] != -1; i = next[i], mark++)</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                        {</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                                ln = len[i];</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                                eln = elen[i];</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                                <span class="keywordflow">for</span>(p = Cp[i]+1; p &lt;= Cp[i] + ln-1; p++) w[Ci[p]] = mark;</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                                jlast = i;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                                <span class="keywordflow">for</span>(j = next[i]; j != -1; ) <span class="comment">/* compare i with all j */</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                                {</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                                        ok = (len[j] == ln) &amp;&amp; (elen[j] == eln);</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                                        <span class="keywordflow">for</span>(p = Cp[j] + 1; ok &amp;&amp; p &lt;= Cp[j] + ln - 1; p++)</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                                        {</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                                                <span class="keywordflow">if</span>(w[Ci[p]] != mark) ok = 0;    <span class="comment">/* compare i and j*/</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                                        }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                                        <span class="keywordflow">if</span>(ok)                     <span class="comment">/* i and j are identical */</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                                        {</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                                                Cp[j] = <a class="code" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a> (i);  <span class="comment">/* absorb j into i */</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                                                nv[i] += nv[j];</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                                                nv[j] = 0;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                                                elen[j] = -1;         <span class="comment">/* node j is dead */</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                                                j = next[j];          <span class="comment">/* delete j from hash bucket */</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                                                next[jlast] = j;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                                        }</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                                        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                                        {</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                                                jlast = j;             <span class="comment">/* j and i are different */</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                                                j = next[j];</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                                        }</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                                }</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                        }</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                }</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;                </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;                <span class="comment">/* --- Finalize new element------------------------------------------ */</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                <span class="keywordflow">for</span>(p = pk1, pk = pk1; pk &lt; pk2; pk++)   <span class="comment">/* finalize Lk */</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                {</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                        i = Ci[pk];</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                        <span class="keywordflow">if</span>((nvi = -nv[i]) &lt;= 0) <span class="keywordflow">continue</span>;<span class="comment">/* skip if i is dead */</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                        nv[i] = nvi;                      <span class="comment">/* restore nv[i] */</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                        d = degree[i] + dk - nvi;         <span class="comment">/* compute external degree(i) */</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                        d = std::min(d, n - nel - nvi);</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                        <span class="keywordflow">if</span>(head[d] != -1) last[head[d]] = i;</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                        next[i] = head[d];               <span class="comment">/* put i back in degree list */</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                        last[i] = -1;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                        head[d] = i;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;                        mindeg = std::min(mindeg, d);       <span class="comment">/* find new minimum degree */</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;                        degree[i] = d;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;                        Ci[p++] = i;                      <span class="comment">/* place i in Lk */</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                }</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                nv[k] = nvk;                      <span class="comment">/* # nodes absorbed into k */</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                <span class="keywordflow">if</span>((len[k] = p-pk1) == 0)         <span class="comment">/* length of adj list of element k*/</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;                {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                        Cp[k] = -1;                   <span class="comment">/* k is a root of the tree */</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;                        w[k] = 0;                     <span class="comment">/* k is now a dead element */</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;                }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                <span class="keywordflow">if</span>(elenk != 0) cnz = p;           <span class="comment">/* free unused space in Lk */</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        }</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        </div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <span class="comment">/* --- Postordering ----------------------------------------------------- */</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        <span class="keywordflow">for</span>(i = 0; i &lt; n; i++) Cp[i] = <a class="code" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a> (Cp[i]);<span class="comment">/* fix assembly tree */</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <span class="keywordflow">for</span>(j = 0; j &lt;= n; j++) head[j] = -1;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="keywordflow">for</span>(j = n; j &gt;= 0; j--)              <span class="comment">/* place unordered nodes in lists */</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        {</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                <span class="keywordflow">if</span>(nv[j] &gt; 0) <span class="keywordflow">continue</span>;          <span class="comment">/* skip if j is an element */</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;                next[j] = head[Cp[j]];          <span class="comment">/* place j in list of its parent */</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;                head[Cp[j]] = j;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        }</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;        <span class="keywordflow">for</span>(e = n; e &gt;= 0; e--)              <span class="comment">/* place elements in lists */</span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        {</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                <span class="keywordflow">if</span>(nv[e] &lt;= 0) <span class="keywordflow">continue</span>;         <span class="comment">/* skip unless e is an element */</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                <span class="keywordflow">if</span>(Cp[e] != -1)</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                        next[e] = head[Cp[e]];      <span class="comment">/* place e in list of its parent */</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                        head[Cp[e]] = e;</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        }</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        </div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;        <span class="keywordflow">for</span>(k = 0, i = 0; i &lt;= n; i++)       <span class="comment">/* postorder the assembly tree */</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        {</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                <span class="keywordflow">if</span>(Cp[i] == -1) k = <a class="code" href="namespaceamd.html#a3a3538487048ffb0e8c35ece6e2c09ad">amd::tdfs</a>(i, k, head, next, temp_perm, w);</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        }</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                perm[i] = temp_perm[i];</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        }</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        </div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <span class="keyword">delete</span>[] W;</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keyword">delete</span>[] temp_perm;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keyword">delete</span>[] Cp;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="keyword">delete</span>[] Ci;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        </div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;}</div>
<div class="ttc" id="namespaceamd_html_a3a3538487048ffb0e8c35ece6e2c09ad"><div class="ttname"><a href="namespaceamd.html#a3a3538487048ffb0e8c35ece6e2c09ad">amd::tdfs</a></div><div class="ttdeci">int tdfs(int j, int k, int *head, const int *next, int *post, int *stack)</div><div class="ttdef"><b>Definition:</b> lilc_matrix_sym_amd.h:26</div></div>
<div class="ttc" id="namespaceamd_html_a964ea0a8fe5f1a327fc93878ff150923"><div class="ttname"><a href="namespaceamd.html#a964ea0a8fe5f1a327fc93878ff150923">amd::wclear</a></div><div class="ttdeci">int wclear(int mark, int lemax, int *w, int n)</div><div class="ttdef"><b>Definition:</b> lilc_matrix_sym_amd.h:12</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a29e9ea5f7c8a9fca9029a91b39c592e0"><div class="ttname"><a href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">lil_sparse_matrix::n_rows</a></div><div class="ttdeci">int n_rows() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:46</div></div>
<div class="ttc" id="namespaceamd_html_a2258ddc3fc379b771d1efc51d7352f2f"><div class="ttname"><a href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f">amd::amd_flip</a></div><div class="ttdeci">int amd_flip(const int &amp;i)</div><div class="ttdef"><b>Definition:</b> lilc_matrix_sym_amd.h:9</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a7319334b43609089b10764dcd0df64cb"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a></div><div class="ttdeci">double max(vector&lt; el_type &gt; &amp;v, vector&lt; int &gt; &amp;curr_nnzs, int &amp;r)</div><div class="ttdoc">Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:40</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a40bc09d3b6716e57134eed0aeba49199"><div class="ttname"><a href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">lil_sparse_matrix::nnz</a></div><div class="ttdeci">int nnz() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:58</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_add59bf538bd6b36c7d42ec879bad4da8_cgraph.png" border="0" usemap="#classlilc__matrix_add59bf538bd6b36c7d42ec879bad4da8_cgraph" alt=""/></div>
<map name="classlilc__matrix_add59bf538bd6b36c7d42ec879bad4da8_cgraph" id="classlilc__matrix_add59bf538bd6b36c7d42ec879bad4da8_cgraph">
<area shape="rect" id="node2" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index. " alt="" coords="235,5,283,32"/><area shape="rect" id="node3" href="namespaceamd.html#a964ea0a8fe5f1a327fc93878ff150923" title="amd::wclear" alt="" coords="210,56,307,83"/><area shape="rect" id="node4" href="namespaceamd.html#a2258ddc3fc379b771d1efc51d7352f2f" title="amd::amd_flip" alt="" coords="205,107,312,133"/><area shape="rect" id="node5" href="namespaceamd.html#a3a3538487048ffb0e8c35ece6e2c09ad" title="amd::tdfs" alt="" coords="219,157,298,184"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a37fc8dcc40799dfde0decaaf8bd74b51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_equil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A, where S is a diagonal scaling matrix. </p>
<p>This algorithm is based on the one outlined in "Equilibration of Symmetric Matrices in the Max-Norm" by Bunch (1971). </p>
<div class="fragment"><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;                                       {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        <span class="comment">//find termination points for loops with binary search later.</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        <span class="keywordtype">int</span> i, ncols = <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>();</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        <span class="comment">// this is required since we do S[i] = max(S[i], ...)</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>.resize(ncols, 0);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        std::pair&lt;idx_it, elt_it&gt; elem_its;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; ncols; i++) {</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;                <span class="comment">//assumes diag elem is always in 0th pos. if possible.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;                <span class="keywordflow">if</span> (!<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].empty() &amp;&amp; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i][0] == i)</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                        <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i] = sqrt(abs(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][0]));</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                <span class="comment">//assumes indices are ordered. since this procedure is run</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                <span class="comment">//before factorization pivots matrix, this is a fair assumption</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                <span class="comment">//for most matrix market matrices.</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i].end(); it++) {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                        <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i] = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">std::max</a>(<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i], abs(<a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a>(i, *it)));</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                }</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;                <span class="comment">//S[i] &gt; 0 since its the square root of a +ve number</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i] &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) { </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i].end(); it++) {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                <a class="code" href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">coeffRef</a>(i, *it, elem_its);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                <span class="comment">//can use bin. search on coeff since no reordering is done yet.</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                                *(elem_its.second) /= <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i]; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                        }</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                        <span class="keywordflow">if</span> (!<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].empty() &amp;&amp; (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i][0] == i) ) </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][0] /= <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i];</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> it = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i].begin(); it != <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i].end(); it++) {</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                                *it /= <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i];</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                        }</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                } </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        }</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        </div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; ncols; i++) {</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i] &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> it = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i].begin(); it != <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i].end(); it++) {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                                <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i] = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">std::max</a>(<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i], abs(*it));</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                        }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                        <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i] &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a>) {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                                std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: Matrix has a null column/row.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                                <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                        }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                        </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                        <span class="keywordflow">for</span> (<a class="code" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> it = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i].begin(); it != <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i].end(); it++) {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                                *it /= <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i];</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                }</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        }</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; ncols; i++) {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i]  = 1.0/<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a>[i];</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        }</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlilc__matrix_html_afc4659265addfeab376ffaa8f54ed596"><div class="ttname"><a href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">lilc_matrix::S</a></div><div class="ttdeci">block_diag_matrix&lt; el_type &gt; S</div><div class="ttdoc">A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:49</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlilc__matrix_html_ad34c37b7095e283a7e5d7160fe26fd1b"><div class="ttname"><a href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">lilc_matrix::elt_it</a></div><div class="ttdeci">elt_vector_type::iterator elt_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:42</div></div>
<div class="ttc" id="classlilc__matrix_html_a327c165f0c90cd362dd14fc6421ebadd"><div class="ttname"><a href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">lilc_matrix::coeffRef</a></div><div class="ttdeci">bool coeffRef(const int &amp;i, const int &amp;j, std::pair&lt; idx_it, elt_it &gt; &amp;its)</div><div class="ttdoc">Finds the index/value pointers to (i,j)th coefficient of the matrix. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:98</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_aad3da1e95c480c7ea84f1889501c3737"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#aad3da1e95c480c7ea84f1889501c3737">idx_it</a></div><div class="ttdeci">vector&lt; int &gt;::iterator idx_it</div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:7</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_af764d0312eb9f7939ab144b12972bf56"><div class="ttname"><a href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">lil_sparse_matrix::eps</a></div><div class="ttdeci">el_type eps</div><div class="ttdoc">Machine epsilon for el_type. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:33</div></div>
<div class="ttc" id="classlilc__matrix_html_a0e59d373ec514c8cb264da653d36f753"><div class="ttname"><a href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">lilc_matrix::coeff</a></div><div class="ttdeci">virtual el_type coeff(const int &amp;i, const int &amp;j, int offset=0) const </div><div class="ttdoc">Finds the (i,j)th coefficient of the matrix. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:76</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
<div class="ttc" id="lilc__matrix__ildl__helpers_8h_html_a7319334b43609089b10764dcd0df64cb"><div class="ttname"><a href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb">max</a></div><div class="ttdeci">double max(vector&lt; el_type &gt; &amp;v, vector&lt; int &gt; &amp;curr_nnzs, int &amp;r)</div><div class="ttdoc">Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_ildl_helpers.h:40</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac88631204bcf7c9a223fb082a7d0cd3d"><div class="ttname"><a href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">lil_sparse_matrix::n_cols</a></div><div class="ttdeci">int n_cols() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:52</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a37fc8dcc40799dfde0decaaf8bd74b51_cgraph.png" border="0" usemap="#classlilc__matrix_a37fc8dcc40799dfde0decaaf8bd74b51_cgraph" alt=""/></div>
<map name="classlilc__matrix_a37fc8dcc40799dfde0decaaf8bd74b51_cgraph" id="classlilc__matrix_a37fc8dcc40799dfde0decaaf8bd74b51_cgraph">
<area shape="rect" id="node2" href="lilc__matrix__ildl__helpers_8h.html#a7319334b43609089b10764dcd0df64cb" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index. " alt="" coords="208,5,256,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af72f55f6880cef04205eb3df7018bce9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_perm </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a permutation vector perm, A is permuted to P'AP, where P is the permutation matrix associated with perm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>the permutation vector. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                                                          {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        vector&lt;idx_vector_type&gt; m_idx_new(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        vector&lt;elt_vector_type&gt; m_x_new(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        <span class="keywordtype">int</span> i, j, pi, pj;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        el_type px;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        vector&lt;int&gt; pinv(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>; i++) {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                pinv[perm[i]] = i;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i].clear();</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        }</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>; j++) { <span class="comment">//no need to use function call n_cols() every iter</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                pj = pinv[j];</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                <span class="keywordflow">for</span> (i = 0; i &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].size(); i++) {</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                        pi = pinv[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j][i]];</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;                        px = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j][i];</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;                        </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                        <span class="keywordflow">if</span> (pi &lt; pj) {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                m_idx_new[ pi ].push_back(pj);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                m_x_new[ pi ].push_back(px);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;                                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[pj].push_back(pi);</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                                </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                m_idx_new[ pj ].push_back(pi);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                m_x_new[ pj ].push_back(px);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                                <span class="keywordflow">if</span> (pi != pj)</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[pi].push_back(pj);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                                </div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                        }</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        }</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        m_idx.swap(m_idx_new);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>.swap(m_x_new);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>; i++) {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                <a class="code" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a>(i, i, m_idx[i]);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                <a class="code" href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a>(i, i, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a>[i], <span class="keyword">true</span>);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        }</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_aab335a46ece471fd0edf52540e24225a"><div class="ttname"><a href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">lil_sparse_matrix::m_n_cols</a></div><div class="ttdeci">int m_n_cols</div><div class="ttdoc">Number of cols in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:31</div></div>
<div class="ttc" id="classlilc__matrix_html_aa1d3045545357a8f33955a87dc55f3aa"><div class="ttname"><a href="classlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">lilc_matrix::ensure_invariant</a></div><div class="ttdeci">void ensure_invariant(const int &amp;j, const int &amp;k, Container &amp;con, bool update_list=false)</div><div class="ttdoc">Ensures two the invariants observed by A.first and A.list are held. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:285</div></div>
<div class="ttc" id="classlilc__matrix_html_ad942a0e5503a2b4327a12287432fca81"><div class="ttname"><a href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">lilc_matrix::list</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; list</div><div class="ttdoc">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_declarations.h:44</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab34914d2b48a5bf14e7ef22e89d2f2e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_rcm </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Reverse Cuthill-McKee ordering of the matrix A (stored in perm). </p>
<p>A detailed description of this function as well as all its subfunctions can be found in "Computer Solution of Large Sparse Positive Definite Systems" by George and Liu (1981). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>An empty permutation vector (filled on function completion). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                                                             {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        <span class="keywordtype">int</span> i, s;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        vector&lt;bool&gt; visited(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        vector&lt;int&gt; lvl_set;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a>; i++) {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                <span class="keywordflow">if</span> (visited[i]) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                lvl_set.clear();</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                s = i;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                <a class="code" href="classlilc__matrix.html#a46161695c5bfb0f43a7dedb9b9146fef">find_root</a>(s);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                lvl_set.push_back(s);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                perm.push_back(s);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                <a class="code" href="structby__degree.html">by_degree&lt;el_type&gt;</a> sorter(<span class="keyword">this</span>);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                visited[s] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                <span class="keywordflow">while</span> (<a class="code" href="classlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5">find_level_set</a>(lvl_set, visited)) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                        sort(lvl_set.begin(), lvl_set.end(), sorter);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                        perm.insert( perm.end(), lvl_set.begin(), lvl_set.end() );      </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                }</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        reverse(perm.begin(), perm.end());</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div>
<div class="ttc" id="structby__degree_html"><div class="ttname"><a href="structby__degree.html">by_degree</a></div><div class="ttdoc">Functor for comparing elements by degree (in increasing order) instead of by index. </div><div class="ttdef"><b>Definition:</b> lilc_matrix_sym_rcm.h:9</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_aab335a46ece471fd0edf52540e24225a"><div class="ttname"><a href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">lil_sparse_matrix::m_n_cols</a></div><div class="ttdeci">int m_n_cols</div><div class="ttdoc">Number of cols in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:31</div></div>
<div class="ttc" id="classlilc__matrix_html_a46161695c5bfb0f43a7dedb9b9146fef"><div class="ttname"><a href="classlilc__matrix.html#a46161695c5bfb0f43a7dedb9b9146fef">lilc_matrix::find_root</a></div><div class="ttdeci">void find_root(int &amp;s)</div><div class="ttdoc">Returns a pseudo-peripheral root of A. This is essentially many chained breadth-first searchs across ...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_find_root.h:6</div></div>
<div class="ttc" id="classlilc__matrix_html_ad343cd9b2f435f40a9866de050f63ce5"><div class="ttname"><a href="classlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5">lilc_matrix::find_level_set</a></div><div class="ttdeci">bool find_level_set(vector&lt; int &gt; &amp;lvl_set, vector&lt; bool &gt; &amp;visited)</div><div class="ttdoc">Returns the next level set given the current level set of A. This is essentially all neighbours of th...</div><div class="ttdef"><b>Definition:</b> lilc_matrix_find_level_set.h:6</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a60c5a4a0ec9a49d43be087b6d67f4df2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string representation of A, with each column and its corresponding indices &amp; non-zero values printed. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representation of this matrix. </dd></dl>

<p>Implements <a class="el" href="classlil__sparse__matrix.html#a5c2c43867660473176de5c73ebdac7be">lil_sparse_matrix&lt; el_type &gt;</a>.</p>
<div class="fragment"><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;{</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  std::ostringstream os;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#ifdef SYM_ILDL_DEBUG</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  os &lt;&lt; <span class="stringliteral">&quot;List of Lists Matrix (&quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9">m_n_rows</a> &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a> &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(); i++) {</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;Column &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;Row      Indices = &quot;</span>  &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i] &lt;&lt; std::endl;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;Non-zero Values  = &quot;</span>  &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i]       &lt;&lt; std::endl;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    os &lt;&lt; std::endl;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  }</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <span class="keywordflow">return</span> os.str();</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div>
<div class="ttc" id="classlil__sparse__matrix_html_ac2abac5da68172e1e3e21376247643de"><div class="ttname"><a href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">lil_sparse_matrix::m_x</a></div><div class="ttdeci">vector&lt; elt_vector_type &gt; m_x</div><div class="ttdoc">The values of the nonzeros in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:36</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a133b6db4ddc63626a8787abbb2564aa6"><div class="ttname"><a href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">lil_sparse_matrix::m_idx</a></div><div class="ttdeci">vector&lt; idx_vector_type &gt; m_idx</div><div class="ttdoc">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...</div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:35</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_aab335a46ece471fd0edf52540e24225a"><div class="ttname"><a href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">lil_sparse_matrix::m_n_cols</a></div><div class="ttdeci">int m_n_cols</div><div class="ttdoc">Number of cols in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:31</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a6eac075dab519f837ae660c9ef933eb9"><div class="ttname"><a href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9">lil_sparse_matrix::m_n_rows</a></div><div class="ttdeci">int m_n_rows</div><div class="ttdoc">Number of rows in the matrix. </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:28</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_a40bc09d3b6716e57134eed0aeba49199"><div class="ttname"><a href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">lil_sparse_matrix::nnz</a></div><div class="ttdeci">int nnz() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:58</div></div>
<div class="ttc" id="classlil__sparse__matrix_html_ac88631204bcf7c9a223fb082a7d0cd3d"><div class="ttname"><a href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">lil_sparse_matrix::n_cols</a></div><div class="ttdeci">int n_cols() const </div><div class="ttdef"><b>Definition:</b> lil_sparse_matrix.h:52</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a36c12de6fccae4ac5a885e8aa60788e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::col_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i, k). </p>

</div>
</div>
<a class="anchor" id="ad942a0e5503a2b4327a12287432fca81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may swap between two rows, we require linked lists for each row of A. </p>

</div>
</div>
<a class="anchor" id="a2ca57e0c3866ed0cf1f17f6253666ebb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::row_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i, k). </p>

</div>
</div>
<a class="anchor" id="afc4659265addfeab376ffaa8f54ed596"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt;el_type&gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::S</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the <a class="el" href="classlilc__matrix.html#a37fc8dcc40799dfde0decaaf8bd74b51" title="The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A...">sym_equil()</a> function, after which SAS will be stored in place of A. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/<a class="el" href="lilc__matrix_8h_source.html">lilc_matrix.h</a></li>
<li>source/<a class="el" href="lilc__matrix__declarations_8h_source.html">lilc_matrix_declarations.h</a></li>
<li>source/<a class="el" href="lilc__matrix__find__level__set_8h_source.html">lilc_matrix_find_level_set.h</a></li>
<li>source/<a class="el" href="lilc__matrix__find__root_8h_source.html">lilc_matrix_find_root.h</a></li>
<li>source/<a class="el" href="lilc__matrix__ildl_8h_source.html">lilc_matrix_ildl.h</a></li>
<li>source/<a class="el" href="lilc__matrix__ildl__inplace_8h_source.html">lilc_matrix_ildl_inplace.h</a></li>
<li>source/<a class="el" href="lilc__matrix__load_8h_source.html">lilc_matrix_load.h</a></li>
<li>source/<a class="el" href="lilc__matrix__pivot_8h_source.html">lilc_matrix_pivot.h</a></li>
<li>source/<a class="el" href="lilc__matrix__save_8h_source.html">lilc_matrix_save.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__amd_8h_source.html">lilc_matrix_sym_amd.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__equil_8h_source.html">lilc_matrix_sym_equil.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__perm_8h_source.html">lilc_matrix_sym_perm.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__rcm_8h_source.html">lilc_matrix_sym_rcm.h</a></li>
<li>source/<a class="el" href="lilc__matrix__to__string_8h_source.html">lilc_matrix_to_string.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 6 2015 15:37:35 for sym-ildl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
