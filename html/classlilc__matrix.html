<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>matrix-factor: lilc_matrix&lt; el_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">matrix-factor&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">Incomplete LDL' factorizations of symmetric matrices.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">lilc_matrix&lt; el_type &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lilc_matrix" --><!-- doxytag: inherits="lil_sparse_matrix" -->
<p>A matrix using the compressed sparse column format.  
 <a href="classlilc__matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lilc__matrix__declarations_8h_source.html">lilc_matrix_declarations.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lilc_matrix&lt; el_type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix__inherit__graph.png" border="0" usemap="#lilc__matrix_3_01el__type_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="lilc__matrix_3_01el__type_01_4_inherit__map" id="lilc__matrix_3_01el__type_01_4_inherit__map">
<area shape="rect" id="node2" href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices." alt="" coords="5,5,203,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for lilc_matrix&lt; el_type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix__coll__graph.png" border="0" usemap="#lilc__matrix_3_01el__type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="lilc__matrix_3_01el__type_01_4_coll__map" id="lilc__matrix_3_01el__type_01_4_coll__map">
<area shape="rect" id="node2" href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices." alt="" coords="222,96,420,123"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classlilc__matrix-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a><br class="typebreak"/>
&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">idx_vector_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a><br class="typebreak"/>
&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">elt_vector_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef idx_vector_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef elt_vector_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::deque&lt; int &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a784e8753e07699d69d0c16ff63e1d218">list_it</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#acdaad0931ff27d7bfc361d3033713914">lilc_matrix</a> (int n_rows=0, int n_cols=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual el_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c">coeff</a> (const int &amp;i, const int &amp;j) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">coeffRef</a> (const int &amp;i, const int &amp;j, std::pair&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a>, <a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> &gt; &amp;its)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">resize</a> (int n_rows, int n_cols)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aec93c7ce204b3f5f61ac8ba090578f43">ildl</a> (<a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;L, <a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;D, <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;perm, int lfil, double tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ae72aca96f9bfbd86b9db271ed18341cb">pivot</a> (vector&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a> &gt; &amp;swapk, vector&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a> &gt; &amp;swapr, vector&lt; <a class="el" href="classlilc__matrix.html#a784e8753e07699d69d0c16ff63e1d218">list_it</a> &gt; &amp;swapk_, vector&lt; <a class="el" href="classlilc__matrix.html#a784e8753e07699d69d0c16ff63e1d218">list_it</a> &gt; &amp;swapr_, <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;all_swaps, vector&lt; bool &gt; &amp;in_set, <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;col_k, <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;col_k_nnzs, <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;col_r, <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;col_r_nnzs, <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;L, const int &amp;k, const int &amp;r)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f">ensure_invariant</a> (const int &amp;j, const int &amp;k, Container &amp;con, int offset, bool update_list=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a> (const int &amp;k)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a> (const int &amp;k)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a60c5a4a0ec9a49d43be087b6d67f4df2">to_string</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aea5613e9a57231a6991dcf99d6d7b37a">load</a> (std::string filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ac7ae3a4b8a4dbf7ad111a9546e261f47">save</a> (std::string filename)</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::deque&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class el_type&gt;<br/>
class lilc_matrix&lt; el_type &gt;</h3>

<p>A matrix using the compressed sparse column format. </p>
<p>In compressed sparse column storage, the col_idx array is of size N + 1. col_idx[j] gives the starting position of the first non-zero element in column j. Hence col_idx[j+1] - col_idx[j] gives the total number of non-zero values in column j and therefore, col_idx[n_cols] gives the total number of non-zero elements in the matrix.</p>
<p>row_idx[j] and m_x[j] are arrays of size n_nzs, so col_idx[n_cols] == row_idx.size() </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ad34c37b7095e283a7e5d7160fe26fd1b"></a><!-- doxytag: member="lilc_matrix::elt_it" ref="ad34c37b7095e283a7e5d7160fe26fd1b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef elt_vector_type::iterator <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5a7b6e31a6c9ebf2ea3a898fe646af6"></a><!-- doxytag: member="lilc_matrix::elt_vector_type" ref="aa5a7b6e31a6c9ebf2ea3a898fe646af6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a>&lt;el_type&gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">lil_sparse_matrix&lt; el_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8cd399b5bc0ef50dcf5a59a671e32248"></a><!-- doxytag: member="lilc_matrix::idx_it" ref="a8cd399b5bc0ef50dcf5a59a671e32248" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef idx_vector_type::iterator <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a83c70482c28275881562ee3937b5f591"></a><!-- doxytag: member="lilc_matrix::idx_vector_type" ref="a83c70482c28275881562ee3937b5f591" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a>&lt;el_type&gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">lil_sparse_matrix&lt; el_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a784e8753e07699d69d0c16ff63e1d218"></a><!-- doxytag: member="lilc_matrix::list_it" ref="a784e8753e07699d69d0c16ff63e1d218" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::deque&lt; int &gt;::iterator <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#a784e8753e07699d69d0c16ff63e1d218">list_it</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acdaad0931ff27d7bfc361d3033713914"></a><!-- doxytag: member="lilc_matrix::lilc_matrix" ref="acdaad0931ff27d7bfc361d3033713914" args="(int n_rows=0, int n_cols=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html">lilc_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                                    : 
        <a class="code" href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices.">lil_sparse_matrix&lt;el_type&gt;</a> (<a class="code" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>) 
        {
                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>.reserve(<a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>);
                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>.reserve(<a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>);
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph.png" border="0" usemap="#classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph" alt=""/></div>
<map name="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph" id="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph">
<area shape="rect" id="node3" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2" title="lil_sparse_matrix::n_cols" alt="" coords="206,5,381,32"/></map>
</div>
</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a177dde39764c88fe4e82b050a5e60303"></a><!-- doxytag: member="lilc_matrix::advance_first" ref="a177dde39764c88fe4e82b050a5e60303" args="(const int &amp;k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::advance_first </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                                {
                <span class="keywordtype">int</span> offset;
                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].begin(); it != <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].end(); it++) {    
                        <span class="comment">//ensure invariant (perhaps not needed here since the invariant is always ensured during pivoting).</span>
                        offset = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it];

                        <span class="keywordflow">if</span> (offset &gt;= (<span class="keywordtype">int</span>) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].size()) <span class="keywordflow">continue</span>;
                        
                        <a class="code" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f">ensure_invariant</a>(*it, k, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it], offset);
                        
                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it][offset] == k)
                                <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it]++;
                }
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph.png" border="0" usemap="#classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph" alt=""/></div>
<map name="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph" id="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph">
<area shape="rect" id="node3" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f" title="lilc_matrix::ensure_invariant" alt="" coords="229,5,424,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab9ee09328b84657630f52631ea8e5eb1"></a><!-- doxytag: member="lilc_matrix::advance_list" ref="ab9ee09328b84657630f52631ea8e5eb1" args="(const int &amp;k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::advance_list </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                               {
                        



                        <span class="keywordtype">int</span> offset;
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].begin(); it != <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].end(); it++) {
                                offset = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it];
                                

                                <span class="keywordflow">if</span> (offset &gt;= (<span class="keywordtype">int</span>) <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[*it].size()) <span class="keywordflow">continue</span>;
                                
                                <a class="code" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f">ensure_invariant</a>(*it, k, <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[*it], offset, <span class="keyword">true</span>);
                                
                                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[*it][offset] == k)
                                        <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it]++;
                        }
                                        
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph.png" border="0" usemap="#classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph" alt=""/></div>
<map name="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph" id="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph">
<area shape="rect" id="node3" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f" title="lilc_matrix::ensure_invariant" alt="" coords="224,5,419,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a325231991a1f4f36c3eb2326b948010c"></a><!-- doxytag: member="lilc_matrix::coeff" ref="a325231991a1f4f36c3eb2326b948010c" args="(const int &amp;i, const int &amp;j) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual el_type <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::coeff </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the (i,j)th coefficient of the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The (i,j)th element of the matrix. </dd></dl>

<p>Implements <a class="el" href="classlil__sparse__matrix.html#ab07c1e7d548a442634bfa694f56befe9">lil_sparse_matrix&lt; el_type &gt;</a>.</p>
<div class="fragment"><pre class="fragment">        {               
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].size(); k++) {
                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j][k] == i) <span class="keywordflow">return</span> <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j][k];
                }
                
                <span class="keywordflow">return</span> 0;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a327c165f0c90cd362dd14fc6421ebadd"></a><!-- doxytag: member="lilc_matrix::coeffRef" ref="a327c165f0c90cd362dd14fc6421ebadd" args="(const int &amp;i, const int &amp;j, std::pair&lt; idx_it, elt_it &gt; &amp;its)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::coeffRef </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a>, <a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>its</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the (i,j)th coefficient of the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if (i,j)th element is nonzero, false otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">        {       
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].size(); k++) {
                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j][k] == i) {
                                its = make_pair(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].begin() + k, <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j].begin() + k);
                                <span class="keywordflow">return</span> <span class="keyword">true</span>;
                        }
                }
                
                its = make_pair(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].end(), <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j].end());
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a2aaa6ad737e4d528e5cf9745531e3c0f"></a><!-- doxytag: member="lilc_matrix::ensure_invariant" ref="a2aaa6ad737e4d528e5cf9745531e3c0f" args="(const int &amp;j, const int &amp;k, Container &amp;con, int offset, bool update_list=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ensure_invariant </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_list</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">                                                                                                                       {
                <span class="keywordflow">if</span> (con.empty() || con[offset] == k) <span class="keywordflow">return</span>;
                
                <span class="keywordtype">int</span> i, min(0);
                <span class="keywordflow">for</span> (i = offset; i &lt; (int) con.size(); i++) {
                        min = offset;
                        <span class="keywordflow">if</span> (con[i] == k) {
                                min = i; 
                                <span class="keywordflow">break</span>;
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( con[i] &lt; con[min] ) {
                                min = i;
                        }
                }
                
                <span class="keywordflow">if</span> (update_list)
                        std::swap(con[offset], con[min]);
                <span class="keywordflow">else</span> {
                        std::swap(con[<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[j]], con[min]);
                        std::swap(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j][<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[j]], <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j][min]);
                }
        }
</pre></div>
</div>
</div>
<a class="anchor" id="aec93c7ce204b3f5f61ac8ba090578f43"></a><!-- doxytag: member="lilc_matrix::ildl" ref="aec93c7ce204b3f5f61ac8ba090578f43" args="(lilc_matrix&lt; el_type &gt; &amp;L, block_diag_matrix&lt; el_type &gt; &amp;D, idx_vector_type &amp;perm, int lfil, double tol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ildl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lfil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs an LDL' factorization of this matrix. The factorization is performed in crout order and follows the algorithm outlined in "Crout versions of the ILU factorization with pivoting for sparse symmetric matrices" by Li and Saad (2005). Results are stored in L and D. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>the L factor of this matrix. </td></tr>
    <tr><td class="paramname">D</td><td>the D factor of this matrix. </td></tr>
    <tr><td class="paramname">lfil</td><td>a parameter to control memory usage. Each column is guarannted to have fewer than lfil elements. </td></tr>
    <tr><td class="paramname">tol</td><td>a parameter to control agressiveness of dropping. In each column, elements less than tol*norm(column) are dropped. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{       
        <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = (1+sqrt(17))/8;  <span class="comment">//for use in pivoting.</span>
        el_type w1, wr, d1(0), dr(0), det_D, D_inv11, D_inv22, D_inv12, l_11, l_12;
        
        <span class="comment">//L.list is a deque of linked lists that gives the non-zero elements in each row of L. </span>
        <span class="comment">//since at any time we may swap between two rows, we require a linked lists for each row of L. </span>
        <span class="comment">//A deque is used as it might be desirable to deallocate all linked lists for rows i &lt; k on step k </span>
        <span class="comment">//(this is currently not done, as the memory used in maintaining linked lists for all rows is not much).</span>
        
        <span class="keyword">const</span> <span class="keywordtype">int</span> ncols = <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>();
        <span class="comment">//work is a work vector for the current column. L.first is a linked list that gives the first nonzero element in column k with row index i &gt; k. (i.e. the first nonzero in L(k+1:n, k).</span>
        <a class="code" href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">elt_vector_type</a> work(ncols, 0), temp(ncols, 0), col_k, col_r;
        <a class="code" href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">idx_vector_type</a> curr_nnzs, temp_nnzs, col_k_nnzs, col_r_nnzs, all_swaps;  <span class="comment">//non-zeros on current col.</span>
        vector&lt;bool&gt; in_set(ncols, 0);
        std::pair&lt;idx_it, elt_it&gt; its_k, its_r;
        vector&lt;idx_it&gt; swapk, swapr;
        vector&lt;list_it&gt; swapk_, swapr_;
        
        <span class="keywordtype">int</span> count = 0; <span class="comment">//the current non-zero in L.</span>
        <span class="keywordtype">int</span> i, j, k, r, offset, col_size, col_size2(1);
        <span class="keywordtype">bool</span> size_two_piv = <span class="keyword">false</span>;

        L.<a class="code" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">resize</a>(ncols, ncols);
        curr_nnzs.reserve(ncols); <span class="comment">//makes sure that there is enough space if every element in the column is nonzero</span>
        L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>.resize(ncols ); <span class="comment">//allocate a vector of size n for Llist.</span>
        D.<a class="code" href="classblock__diag__matrix.html#a12249531555506377724ff14abec6905">resize</a>(ncols ); 
        
        <span class="keywordflow">for</span> (i = 0; i &lt; ncols; i++) {
                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].resize(lfil+1);
                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i].resize(lfil+1);
        }
        
        <span class="keywordflow">for</span> (k = 0; k &lt; ncols; k++) {


                <span class="comment">// for (auto it = list[3].begin(); it!= list[3].end(); it++) {</span>

                <span class="comment">// }</span>

                
                size_two_piv = <span class="keyword">false</span>;
                
                <span class="comment">//zero out work vector</span>
                std::fill (work.begin() + k, work.end(), 0);
                curr_nnzs.clear();
                
                col_size = 1;
                
                <span class="comment">//future self: remember you need m_idx[k]+1 only if there is a diag elem in A.col(k)</span>
                <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].size() &gt; 0) {
                        offset = 0;
                        <span class="comment">//offset = (m_idx[k][0] == k ? 1 : 0);</span>
                        curr_nnzs.assign (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].begin()+offset, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].end());
                        
                        <span class="comment">//assigns the non zeros in A(k,:) to the work vector. since only the lower diagonal of A is stored, this is essentially A(k,k+1:n).</span>
                        <span class="keywordflow">for</span> (j = 0; j &lt; (int) curr_nnzs.size(); j++) {
                                work[curr_nnzs[j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][j+offset];
                        }
                }
                
                <span class="comment">// d1 = coeff(k,k);</span>
                <span class="comment">// for (auto it = L.list[k].begin(); it != L.list[k].end(); it++) { </span>
                        <span class="comment">// offset = L.first[*it];</span>
                        <span class="comment">// d1 -= L.m_x[*it][offset] * D[*it] * L.m_x[*it][offset];      //update diagonal</span>
                <span class="comment">// }</span>



                        <span class="comment">//--------------begin pivoting--------------//</span>
                        
                        <span class="keywordflow">if</span> (k == 22966) {
                        <span class="comment">//cout &lt;&lt; work &lt;&lt; endl;</span>
                        cout &lt;&lt; curr_nnzs &lt;&lt; endl;
                        }
                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#aa97814d8199ae28757c566f7b13532e9" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs.">update</a>(k, work, curr_nnzs, L, D, in_set, <span class="keyword">true</span>);
                        <span class="keywordflow">if</span> (k == 22966) {
                        <span class="comment">//cout &lt;&lt; work &lt;&lt; endl;</span>
                        cout &lt;&lt; curr_nnzs &lt;&lt; endl;
                        }
                        



                        
                        d1 = work[k];
                        work[k] = 0;
                        
                        w1 = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index.">max</a>(work, curr_nnzs, r);
                        

                        <span class="keywordflow">if</span> (w1 == 0) {
                                <span class="comment">//case 0: do nothing. pivot is k.</span>
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::abs(d1) &gt;= alpha * w1 ) {
                                <span class="comment">//case 1: do nothing. pivot is k.</span>
                        } <span class="keywordflow">else</span> {
                                std::fill (temp.begin() + k, temp.end(), 0);
                                temp_nnzs.clear();
                                
           <span class="comment">//TODO: should it be coeff(r,k)?</span>
                                <span class="comment">// temp[k] = coeff(r,k);</span>
                                <span class="comment">// for (auto it = L.list[k].begin(); it != L.list[k].end(); it++) { </span>
                                        <span class="comment">// offset = L.first[*it];</span>
                                        <span class="comment">// temp[k] -= L.coeff(r, *it) * D[*it] * L.m_x[*it][offset];</span>
                                <span class="comment">// }</span>
                                
                                
                                <a class="code" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f">ensure_invariant</a>(r, k, <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r], <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[r], <span class="keyword">true</span>);
                                offset = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[r];
                                
                                
                                <span class="keywordflow">for</span> (j = offset; j &lt; (int) <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].size(); j++) {
                                        temp_nnzs.push_back(<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][j]);
                                        temp[<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][j]] = <a class="code" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c">coeff</a>(r, list[r][j]);
                                }

                                
                                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65">unordered_inplace_union</a>(temp_nnzs, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end(), in_set);
                                
                                <span class="keywordflow">for</span> (j = 0; j &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].size(); j++) {
                                        temp[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r][j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r][j];
                                }
                                

                                <span class="keywordflow">if</span> (k == 22966) {
                                <span class="comment">//cout &lt;&lt; temp &lt;&lt; endl;</span>
                                cout &lt;&lt; temp_nnzs &lt;&lt; endl;
                                }
                                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#aa97814d8199ae28757c566f7b13532e9" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs.">update</a>(r, temp, temp_nnzs, L, D, in_set, <span class="keyword">true</span>);
                                <span class="keywordflow">if</span> (k == 22966) {
                                <span class="comment">//cout &lt;&lt; temp &lt;&lt; endl;</span>
                                cout &lt;&lt; temp_nnzs &lt;&lt; endl;
                                }


                                
                                dr = temp[r];
                                temp[r] = 0;
                                
                                wr = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index.">max</a>(temp, temp_nnzs, j);
                                


                                <span class="keywordflow">if</span> (std::abs(d1 * wr)&gt;= alpha*w1*w1) {
                                        <span class="comment">//case 2: do nothing. pivot is k.</span>
                                        
                                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::abs(dr) &gt;= std::abs(alpha * wr)) {
                                        <span class="comment">//case 3: pivot is k with r: 1x1 pivot case.</span>
                                        temp[r] = dr;
                                        work[k] = d1;
                                        
                                        <span class="keywordflow">if</span> (k &gt; r) {cout &lt;&lt; <span class="stringliteral">&quot;fault! &quot;</span> &lt;&lt; k+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="keywordflow">return</span>;}
                                        
                                        <span class="comment">//TODO: needed?</span>
                                        <span class="comment">//advance_list(k);</span>
                                        
                                        <span class="comment">//--------pivot A and L ---------//</span>
                                        <a class="code" href="classlilc__matrix.html#ae72aca96f9bfbd86b9db271ed18341cb">pivot</a>(swapk, swapr, swapk_, swapr_, all_swaps, in_set, col_k, col_k_nnzs, col_r, col_r_nnzs, L, k, r);
                                        

                                        <span class="comment">//----------pivot rest ----------//</span>
                                        std::swap(d1, dr);
                                        
                                        <span class="comment">//permute perm</span>
                                        std::swap(perm[k], perm[r]);
                                        
                                        work.swap(temp);        <span class="comment">//swap work with temp.</span>
                                        std::swap(work[k], work[r]);
                                        
                                        curr_nnzs.swap(temp_nnzs);      <span class="comment">//swap curr_nnzs with temp_nnzs</span>
                                        

                                        <span class="comment">//check if this is working.</span>
                                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a3a205752bb9fe0b8462ea2d9929d02be">safe_swap</a>(curr_nnzs, k, r);

                                        <span class="comment">//--------end pivot rest---------//</span>
                                        



                                } <span class="keywordflow">else</span> {
                                        <span class="comment">//case 4: pivot is k+1 with r: 2x2 pivot case.</span>
                                        cout &lt;&lt; <span class="stringliteral">&quot;case 4: &quot;</span> &lt;&lt; k+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;
                                        
                                        <span class="keywordflow">if</span> (k &gt;= r) {cout &lt;&lt; <span class="stringliteral">&quot;fault! &quot;</span> &lt;&lt; k+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="keywordflow">return</span>;}
                                        <span class="comment">//TODO: needed?</span>
                                        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k);
                                        L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k);
                                        
                                        temp[r] = dr;
                                        work[k] = d1;

                                        size_two_piv = <span class="keyword">true</span>;
                                        
                                        <span class="keywordflow">if</span> (k+1 != r) {
                                                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a3a205752bb9fe0b8462ea2d9929d02be">safe_swap</a>(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k], k+1, r);
                                                <a class="code" href="classlilc__matrix.html#ae72aca96f9bfbd86b9db271ed18341cb">pivot</a>(swapk, swapr, swapk_, swapr_, all_swaps, in_set, col_k, col_k_nnzs, col_r, col_r_nnzs, L, k+1, r);
                                                

                                                <span class="comment">//----------pivot rest ----------//</span>
                                                
                                                <span class="comment">//permute perm</span>
                                                std::swap(perm[k+1], perm[r]);
                                                
                                                <span class="comment">//swap two cols of L</span>
                                                std::swap(work[k+1], work[r]);
                                                std::swap(temp[k+1], temp[r]);
                                                
                                                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a3a205752bb9fe0b8462ea2d9929d02be">safe_swap</a>(curr_nnzs, k+1, r);
                                                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a3a205752bb9fe0b8462ea2d9929d02be">safe_swap</a>(temp_nnzs, k+1, r);
                                        }
                                }
                        }
                        <span class="comment">//--------------end pivoting--------------//</span>
                        
                        curr_nnzs.erase(std::remove(curr_nnzs.begin(), curr_nnzs.end(), k), curr_nnzs.end());
                                
                        <span class="comment">//performs the dual dropping procedure.</span>
                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a67cef3500c6f2df4556228bcb05e24ad" title="Performs the dual-dropping criteria outlined in Li &amp; Saad (2005).">drop_tol</a>(work, curr_nnzs, lfil, tol);
                        col_size += std::min(lfil, (<span class="keywordtype">int</span>) curr_nnzs.size());
                        
                        <span class="keywordflow">if</span> (size_two_piv) {
                                temp_nnzs.erase(std::remove(temp_nnzs.begin(), temp_nnzs.end(), k), temp_nnzs.end());

                                curr_nnzs.erase(std::remove(curr_nnzs.begin(), curr_nnzs.end(), k+1), curr_nnzs.end());
                                temp_nnzs.erase(std::remove(temp_nnzs.begin(), temp_nnzs.end(), k+1), temp_nnzs.end());
                                
                                
                                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a67cef3500c6f2df4556228bcb05e24ad" title="Performs the dual-dropping criteria outlined in Li &amp; Saad (2005).">drop_tol</a>(temp, temp_nnzs, lfil, tol);
                                
                                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65">unordered_inplace_union</a>(curr_nnzs, temp_nnzs.begin(), temp_nnzs.end(), in_set);
                                
                                <span class="comment">//col_size2 = 1+std::min(lfil, (int) temp_nnzs.size());</span>
                                col_size = std::min(lfil, (<span class="keywordtype">int</span>) curr_nnzs.size());
                        }
                        
                        
                
                

                
                D[k] = d1;
                
                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][0] = 1;
                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][0] = k;
                count++;
                

                <span class="keywordflow">if</span> (!size_two_piv) {

                        <span class="keywordflow">if</span> (k &lt; ncols - 1)
                        <span class="keywordflow">for</span> (i = 0; i &lt; col_size-1; i++) <span class="comment">//need -1 on col_size to remove offset from initializing col_size to 1</span>
                        {
                                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i+1] = curr_nnzs[i]; <span class="comment">//row_idx of L is updated</span>
                                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i+1] = work[curr_nnzs[i]]/D[k]; <span class="comment">//work vector is scaled by D[k]</span>
                                
                                L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[curr_nnzs[i]].push_back(k); <span class="comment">//update Llist</span>
                                count++;
                        }
                        
                        <span class="comment">//update lfirst</span>
                        L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k);
                        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k);
                } <span class="keywordflow">else</span> {



                        D.<a class="code" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3">off_diagonal</a>(k) = work[k+1];
                        D[k+1] = dr;
                        
                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1][0] = 1;
                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1][0] = k+1;
                        count++;
                        
                        det_D = d1*dr - work[k+1]*work[k+1];
                        

                        <span class="keywordflow">if</span> (det_D != 0) { <span class="comment">//replace with EPS later</span>
                                D_inv11 = dr/det_D;
                                D_inv22 = d1/det_D;
                                D_inv12 = -work[k+1]/det_D;


                                <span class="keywordflow">for</span> (r = 0, i = 0, j = 0; r &lt; col_size; r++) <span class="comment">//need -1 on col_size to remove offset from initializing col_size to 1</span>
                                {
                                        l_11 = work[curr_nnzs[r]]*D_inv11 + temp[curr_nnzs[r]]*D_inv12; 
                                        l_12 = work[curr_nnzs[r]]*D_inv12 + temp[curr_nnzs[r]]*D_inv22; 
                                        
                                        <span class="keywordflow">if</span> (l_11 != 0) {
                                                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i+1] = l_11; <span class="comment">//row_idx of L is updated</span>
                                                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i+1] = curr_nnzs[r]; <span class="comment">//work vector is scaled by D[k]</span>
                                                L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[curr_nnzs[r]].push_back(k); <span class="comment">//update Llist</span>
                                                count++;
                                                i++;
                                        }

                                        <span class="keywordflow">if</span> (l_12 != 0) {
                                                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1][j+1] = l_12; <span class="comment">//row_idx of L is updated</span>
                                                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1][j+1] = curr_nnzs[r]; <span class="comment">//work vector is scaled by D[k]</span>
                                                L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[curr_nnzs[r]].push_back(k+1); <span class="comment">//update Llist</span>
                                                count++;
                                                j++;
                                        }
                                        
                                }

                                
                                col_size = 1 + i;
                                col_size2 = 1 + j;
                                
                                <span class="comment">//update lfirst</span>
                                L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a>(k+1);
                                

                                <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a>(k+1);
                                

                        }
                        

                }

                
                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k].resize(col_size);
                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].resize(col_size);
                
                <span class="keywordflow">if</span> (size_two_piv) {
                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k+1].resize(col_size2);
                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k+1].resize(col_size2);
                        k++;
                }
                
                <span class="comment">// std::string s;</span>
                <span class="comment">// std::cin &gt;&gt; s;</span>
                
                <span class="comment">// switch (s.c_str()[0]) {</span>
                        <span class="comment">// case &#39;a&#39;:</span>

                        <span class="comment">// break;</span>
                        <span class="comment">// case &#39;l&#39;:</span>

                        <span class="comment">// break;</span>
                        <span class="comment">// default:</span>
                                <span class="comment">// break;</span>
                <span class="comment">// }</span>
                
                cout &lt;&lt; k &lt;&lt; endl;
                


        }
        
        L.<a class="code" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">nnz_count</a> = count;
        
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_aec93c7ce204b3f5f61ac8ba090578f43_cgraph.png" border="0" usemap="#classlilc__matrix_aec93c7ce204b3f5f61ac8ba090578f43_cgraph" alt=""/></div>
<map name="classlilc__matrix_aec93c7ce204b3f5f61ac8ba090578f43_cgraph" id="classlilc__matrix_aec93c7ce204b3f5f61ac8ba090578f43_cgraph">
<area shape="rect" id="node3" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303" title="lilc_matrix::advance_first" alt="" coords="409,36,583,62"/><area shape="rect" id="node7" href="lilc__matrix__ildl__helpers_8h.html#a67cef3500c6f2df4556228bcb05e24ad" title="Performs the dual&#45;dropping criteria outlined in Li &amp; Saad (2005)." alt="" coords="212,48,287,74"/><area shape="rect" id="node9" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index." alt="" coords="225,98,273,125"/><area shape="rect" id="node11" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3" title="block_diag_matrix::off_diagonal" alt="" coords="387,250,605,277"/><area shape="rect" id="node13" href="classblock__diag__matrix.html#a12249531555506377724ff14abec6905" title="block_diag_matrix::resize" alt="" coords="160,200,339,226"/><area shape="rect" id="node15" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795" title="lilc_matrix::resize" alt="" coords="185,149,313,176"/><area shape="rect" id="node21" href="lilc__matrix__ildl__helpers_8h.html#a3a205752bb9fe0b8462ea2d9929d02be" title="safe_swap" alt="" coords="204,301,295,328"/><area shape="rect" id="node23" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65" title="unordered_inplace_union" alt="" coords="659,352,842,378"/><area shape="rect" id="node25" href="lilc__matrix__ildl__helpers_8h.html#aa97814d8199ae28757c566f7b13532e9" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs." alt="" coords="217,352,282,378"/><area shape="rect" id="node5" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f" title="lilc_matrix::ensure_invariant" alt="" coords="653,250,848,277"/><area shape="rect" id="node17" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2" title="lil_sparse_matrix::n_cols" alt="" coords="409,124,583,150"/><area shape="rect" id="node19" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76" title="lil_sparse_matrix::n_rows" alt="" coords="406,174,586,201"/><area shape="rect" id="node27" href="classblock__diag__matrix.html#ac06f1c9d979d7e73e51b937452b35574" title="block_diag_matrix::block_size" alt="" coords="393,402,599,429"/><area shape="rect" id="node29" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c" title="lilc_matrix::coeff" alt="" coords="435,352,557,378"/><area shape="rect" id="node32" href="lilc__matrix__ildl__helpers_8h.html#a56cd3d014fb6b03abcc1e59999916ed2" title="update_single" alt="" coords="441,301,551,328"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aea5613e9a57231a6991dcf99d6d7b37a"></a><!-- doxytag: member="lilc_matrix::load" ref="aea5613e9a57231a6991dcf99d6d7b37a" args="(std::string filename)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be loaded. Must be in matrix market format (.mtx). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
        std::ifstream input(filename.c_str(), std::ios::in);

        <span class="keywordflow">if</span>(!input) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        
        <span class="keyword">const</span> <span class="keywordtype">int</span> maxBuffersize = 2048;
        <span class="keywordtype">char</span> buffer[maxBuffersize];

        <span class="keywordtype">bool</span> readsizes = <span class="keyword">false</span>;

        <span class="keywordtype">int</span> <a class="code" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76">n_rows</a>(-1), <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>(-1), n_nzs(-1), i(-1), j(-1);
        <span class="keywordtype">int</span> count = 0;
        el_type value; 

        <span class="keywordflow">while</span>(input.getline(buffer, maxBuffersize))
        {
                <span class="comment">// skip comments   </span>
                <span class="comment">//NOTE An appropriate test should be done on the header to get the symmetry</span>
                <span class="keywordflow">if</span>(buffer[0]==<span class="charliteral">&#39;%&#39;</span>)
                <span class="keywordflow">continue</span>;
                
                std::stringstream line(buffer);
                
                <span class="keywordflow">if</span>(!readsizes)
                {
                        line &gt;&gt; <a class="code" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76">n_rows</a> &gt;&gt; <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a> &gt;&gt; n_nzs;
                        <span class="keywordflow">if</span>(<a class="code" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76">n_rows</a> &gt; 0 &amp;&amp; <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a> &gt; 0 &amp;&amp; n_nzs &gt; 0) 
                        {
                                readsizes = <span class="keyword">true</span>;
                                
                                <a class="code" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">resize</a>(<a class="code" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>);
                                std::fill(<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>.begin(), <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>.end(), 0); <span class="comment">//a bit of optimization could be used here since resize sets all elem in first to 1</span>
                        }
                }
                <span class="keywordflow">else</span>
                { 
                        i = -1;
                        j = -1;
                        <span class="keywordflow">if</span>( <a class="code" href="lilc__matrix__load_8h.html#a6de8c02a91b0862a6d2221d4e8deb59e">readline</a>(line, <a class="code" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>, i, j, value) ) 
                        {

                                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[j].push_back(i);
                                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[j].push_back(value);
                                ++count;
                                
                                <span class="keywordflow">if</span> (i != j) <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[i].push_back(j);
                                
                        }
                        <span class="keywordflow">else</span> 
                        std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid read: &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;         
                }
                
        }
        
        <span class="keywordflow">if</span> (count != n_nzs) std::cout &lt;&lt; <span class="stringliteral">&quot;Expected &quot;</span> &lt;&lt; n_nzs &lt;&lt; <span class="stringliteral">&quot; elems but read &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;
        
        <a class="code" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">nnz_count</a> = count;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Load succeeded. &quot;</span> &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; was loaded.&quot;</span> &lt;&lt; std::endl;
        input.close();
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph.png" border="0" usemap="#classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph" alt=""/></div>
<map name="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph" id="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph">
<area shape="rect" id="node3" href="lilc__matrix__load_8h.html#a6de8c02a91b0862a6d2221d4e8deb59e" title="readline" alt="" coords="171,5,245,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae72aca96f9bfbd86b9db271ed18341cb"></a><!-- doxytag: member="lilc_matrix::pivot" ref="ae72aca96f9bfbd86b9db271ed18341cb" args="(vector&lt; idx_it &gt; &amp;swapk, vector&lt; idx_it &gt; &amp;swapr, vector&lt; list_it &gt; &amp;swapk_, vector&lt; list_it &gt; &amp;swapr_, idx_vector_type &amp;all_swaps, vector&lt; bool &gt; &amp;in_set, elt_vector_type &amp;col_k, idx_vector_type &amp;col_k_nnzs, elt_vector_type &amp;col_r, idx_vector_type &amp;col_r_nnzs, lilc_matrix&lt; el_type &gt; &amp;L, const int &amp;k, const int &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::pivot </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classlilc__matrix.html#a784e8753e07699d69d0c16ff63e1d218">list_it</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapk_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classlilc__matrix.html#a784e8753e07699d69d0c16ff63e1d218">list_it</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>swapr_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>all_swaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>col_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>col_k_nnzs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>col_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>col_r_nnzs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{       
        std::deque&lt;int&gt; row_k, row_r;
        std::vector&lt;int&gt; swap_cols;
        std::pair&lt;idx_it, elt_it&gt; its_k, its_r;
        <span class="keywordtype">int</span> i, j, offset;
        
        row_k.clear();
        row_r.clear();
        
        col_k.clear();
        col_k_nnzs.clear();
        
        col_r.clear();
        col_r_nnzs.clear();
        
        <span class="comment">//TODO: check if two lines below are needed</span>
        <span class="comment">//ensure_invariant(r, k, list[r], first[r], true);</span>
        <span class="comment">//ensure_invariant(k, k, list[k], first[k], true);</span>
        
        <span class="comment">//----------pivot A ----------//</span>
        swapr_.clear();
        swapk_.clear();
        all_swaps.clear();
        
        <span class="comment">//swap A(:, k) with A(:, r)</span>
        <span class="comment">//invariant: ensure m_idx[:][0] and m_x[:][0] contains the smallest index element.</span>
        <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c">coeff</a>(r, r) !=0){
                col_k_nnzs.push_back(k);
                col_k.push_back(<a class="code" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c">coeff</a>(r, r));
        }
        <span class="comment">//TODO: if zero, need to halt linear search.</span>
        
        <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c">coeff</a>(k, k) !=0){
                col_r_nnzs.push_back(r);
                col_r.push_back(<a class="code" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c">coeff</a>(k, k));
        }
        
        <span class="keywordflow">for</span> (i = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[r]; i &lt; (int) <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].size(); i++) {
                <span class="comment">// if (list[r][i] &lt; k) {  //list[r] does not update correctly on each iteration. the invariant is somehow violated. the code below works but is bad code. pretty sure this only fixes a subset of the problems.</span>
                        <span class="comment">// std::swap(list[r][i], list[r][0]);</span>
                        <span class="comment">// list[r].pop_front();</span>
                        <span class="comment">// i--;</span>
                        <span class="comment">// continue;</span>
                <span class="comment">// }</span>
                
                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][i] &lt;= k || <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][i] &gt;= r) <span class="keywordflow">continue</span>;
                <a class="code" href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">coeffRef</a>(r, <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][i], its_k);
                col_k_nnzs.push_back(<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][i]);
                col_k.push_back(*its_k.second);
                
                *its_k.first = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][i]].back();
                *its_k.second = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][i]].back();
                
                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][i]].pop_back();
                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r][i]].pop_back();
        }
        



                
        <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c">coeff</a>(r, k) != 0) {
                col_k_nnzs.push_back(r);
                col_k.push_back(<a class="code" href="classlilc__matrix.html#a325231991a1f4f36c3eb2326b948010c">coeff</a>(r, k));
        }
   <span class="comment">//did we forget to add the kth elem to row_k?</span>




                
        <span class="comment">//is it possible to select an all zeros col as a pivot?</span>
        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].size() &gt; 0) {
                offset = (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r][0] == r ? 1 : 0);
                std::copy(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r].begin()+offset, <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r].end(), std::back_inserter(col_k));
                std::copy(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin()+offset, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end(), std::back_inserter(col_k_nnzs));
                



                <span class="comment">//invariant: ensure list[:][0] contain the index nearest in value to k.</span>
                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].begin() + offset; it != <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].end(); it++) {
                        <span class="keywordflow">for</span> (i = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it]; i &lt; (int) <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[*it].size(); i++) {
                                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[*it][i] == r) {
                                        swapk_.push_back(<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[*it].begin() + i);
                                        all_swaps.push_back(*it);
                                        <span class="keywordflow">break</span>;
                                }
                        }
                }
        }




                
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].begin(); it != <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].begin() + <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[k]; it++) {
                row_r.push_back(*it);
        }
        
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].begin(); it != <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].begin() + <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[r]; it++) {
                row_k.push_back(*it);
        }
        
        
        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].size() &gt; 0) {
                <span class="comment">//swap A(k:r, k) with A(r, k:r);</span>
                offset = (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][0] == k ? 1 : 0);
                <span class="keywordflow">for</span> (i = offset; i &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].size(); i++) {
                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i] &lt; r) {
                                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]].push_back(r);
                                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]].push_back(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i]);
                                
           <span class="comment">//TODO: add ensure_invariant here to be safe</span>
                                std::swap(<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]][<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]]],<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]][<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]].size() - 1]);
                                <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]].pop_back();
                                
                                row_r.push_back(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]);
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i] != r) {
                                col_r.push_back(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k][i]);
                                col_r_nnzs.push_back(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]);
                                
                                <span class="comment">//this part can be simplified since invariant ensures list[:][0] is always the idx closest to k. wont make a diff on running time though</span>
                                <span class="keywordflow">for</span> (j = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]]; j &lt; (int) <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]].size(); j++) {
                                        <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]][j] == k) {
                                                swapr_.push_back(<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]].begin() + j);
                                                all_swaps.push_back(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k][i]);
                                                <span class="keywordflow">break</span>;
                                        }
                                }
                        }
                }
        }
        
        <span class="comment">// swap_cols.clear();</span>
        <span class="comment">// swap_cols.assign(list[k].begin(), list[k].end());</span>
        <span class="comment">// unordered_inplace_union(swap_cols, list[r].begin(), list[r].begin() + first[r], in_set);</span>
        
        <span class="comment">// for (auto it = swap_cols.begin(); it != swap_cols.end(); it++) {</span>


                
                <span class="comment">// safe_swap(m_idx[*it], k, r);</span>
                

        <span class="comment">// }</span>

        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = swapk_.begin(); it != swapk_.end(); it++) {

                **it = k;

        }
        
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = swapr_.begin(); it != swapr_.end(); it++) {
                **it = r;
        }

        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = all_swaps.begin(); it != all_swaps.end(); it++) {
                <a class="code" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f">ensure_invariant</a>(*it, k, <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[*it], <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it], <span class="keyword">true</span>);
        }
        



                
        <span class="comment">//set the kth col</span>
        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[k].swap(col_k_nnzs);
        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[k].swap(col_k);
        
        <span class="comment">//set the rth col</span>
        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[r].swap(col_r_nnzs);
        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[r].swap(col_r);
        
        <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].swap(row_k);
        <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].swap(row_r);

        std::swap(<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[k], <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[r]);
        <span class="comment">//--------end pivot A---------//</span>
        
        <span class="comment">//----------pivot L ----------//</span>
        swapr.clear();
        swapk.clear();
        all_swaps.clear();
        
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].begin(); it != L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].end(); it++)
        {
                <span class="comment">//L.ensure_invariant(*it, k, L.m_idx[*it], L.first[*it]);</span>
                <span class="keywordflow">for</span> (i = L.<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it]; i &lt; (<span class="keywordtype">int</span>) L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].size(); i++) {
                        <span class="keywordflow">if</span> (L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it][i] == k) {
                                swapr.push_back(L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].begin() + i);
                                <span class="keywordflow">break</span>;
                        }
                }
        }
        
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].begin(); it != L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].end(); it++) {
                <span class="comment">//L.ensure_invariant(*it, k, L.m_idx[*it], L.first[*it]);</span>
                <span class="keywordflow">for</span> (i = L.<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it]; i &lt; (<span class="keywordtype">int</span>) L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].size(); i++) {
                        <span class="keywordflow">if</span> (L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it][i] == r) {                             
                                swapk.push_back(L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it].begin() + i);
                                <span class="keywordflow">break</span>;
                        }
                }
        }
        
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = swapk.begin(); it != swapk.end(); it++) {
                **it = k;
        }
        
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = swapr.begin(); it != swapr.end(); it++) {
                **it = r;
        }
        
        all_swaps.assign(L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].begin(), L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r].end());
        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65">unordered_inplace_union</a>(all_swaps, L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].begin(), L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].end(), in_set);
        
        <span class="comment">//invariant: ensure m_idx[:][L.first[i]+1] all contain the index nearest in value to k. </span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = all_swaps.begin(); it != all_swaps.end(); it++) {
                L.<a class="code" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f">ensure_invariant</a>(*it, k, L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[*it], L.<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>[*it]);         
        }
        
        L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[k].swap(L.<a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>[r]);
        <span class="comment">//--------end pivot L---------//</span>
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_ae72aca96f9bfbd86b9db271ed18341cb_cgraph.png" border="0" usemap="#classlilc__matrix_ae72aca96f9bfbd86b9db271ed18341cb_cgraph" alt=""/></div>
<map name="classlilc__matrix_ae72aca96f9bfbd86b9db271ed18341cb_cgraph" id="classlilc__matrix_ae72aca96f9bfbd86b9db271ed18341cb_cgraph">
<area shape="rect" id="node3" href="classlilc__matrix.html#a2aaa6ad737e4d528e5cf9745531e3c0f" title="lilc_matrix::ensure_invariant" alt="" coords="173,5,368,32"/><area shape="rect" id="node5" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65" title="unordered_inplace_union" alt="" coords="179,56,362,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aca815e0ac073abb1e6ef888b09f9e795"></a><!-- doxytag: member="lilc_matrix::resize" ref="aca815e0ac073abb1e6ef888b09f9e795" args="(int n_rows, int n_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resizes the matrix. For use in preallocating space before factorization begins. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n_rows</td><td>the number of rows in the resized matrix. </td></tr>
    <tr><td class="paramname">n_cols</td><td>the number of cols in the resized matrix. </td></tr>
    <tr><td class="paramname">n_nzs</td><td>the number of non-zeros expected in the matrix. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">        {
                <a class="code" href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9">m_n_rows</a> = <a class="code" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76">n_rows</a>;
                <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a> = <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>;
                
                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>.resize(<a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>);
                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>.resize(<a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>);
                
                <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a>.resize(<a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>, 1);
                <a class="code" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a>.resize(<a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>);
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph.png" border="0" usemap="#classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph" alt=""/></div>
<map name="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph" id="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph">
<area shape="rect" id="node3" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2" title="lil_sparse_matrix::n_cols" alt="" coords="185,5,359,32"/><area shape="rect" id="node5" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76" title="lil_sparse_matrix::n_rows" alt="" coords="182,56,362,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac7ae3a4b8a4dbf7ad111a9546e261f47"></a><!-- doxytag: member="lilc_matrix::save" ref="ac7ae3a4b8a4dbf7ad111a9546e261f47" args="(std::string filename)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::save </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be saved. All matrices saved are in matrix market format (.mtx). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
        std::ofstream out(filename.c_str(), std::ios::out | std::ios::binary);
        <span class="keywordflow">if</span>(!out)
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

        out.flags(std::ios_base::scientific);
        out.precision(10);
        std::string header; 
        <a class="code" href="lilc__matrix__save_8h.html#aa7c9d04c7848fbb242800cad7f48c431">put_header</a>(header); 

        out &lt;&lt; header &lt;&lt; std::endl; 
        out &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a81d22dfb8a1af5d790953f0cfa480d76">n_rows</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a417b985bad44766c4d0177cd0af45f76">nnz</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>(); i++) {
                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i].size(); j++) {
                        out &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i][j]+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i][j] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
                }
        }
        
        out.close();
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_ac7ae3a4b8a4dbf7ad111a9546e261f47_cgraph.png" border="0" usemap="#classlilc__matrix_ac7ae3a4b8a4dbf7ad111a9546e261f47_cgraph" alt=""/></div>
<map name="classlilc__matrix_ac7ae3a4b8a4dbf7ad111a9546e261f47_cgraph" id="classlilc__matrix_ac7ae3a4b8a4dbf7ad111a9546e261f47_cgraph">
<area shape="rect" id="node3" href="lilc__matrix__save_8h.html#aa7c9d04c7848fbb242800cad7f48c431" title="put_header" alt="" coords="174,5,269,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a60c5a4a0ec9a49d43be087b6d67f4df2"></a><!-- doxytag: member="lilc_matrix::to_string" ref="a60c5a4a0ec9a49d43be087b6d67f4df2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>A string reprepsentation of this matrix. </dd></dl>

<p>Implements <a class="el" href="classlil__sparse__matrix.html#a5c2c43867660473176de5c73ebdac7be">lil_sparse_matrix&lt; el_type &gt;</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::ostringstream os;
  os &lt;&lt; <span class="stringliteral">&quot;List of Lists Matrix (&quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9">m_n_rows</a> &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a> &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a417b985bad44766c4d0177cd0af45f76">nnz</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
  
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#a6617376009a14e1db65d3eceb665aee2">n_cols</a>(); i++) {
    os &lt;&lt; <span class="stringliteral">&quot;Column &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;
    os &lt;&lt; <span class="stringliteral">&quot;Row      Indices = &quot;</span>  &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a>[i] &lt;&lt; std::endl;
    os &lt;&lt; <span class="stringliteral">&quot;Non-zero Values  = &quot;</span>  &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a>[i]       &lt;&lt; std::endl;
    os &lt;&lt; std::endl;
  }
  
  <span class="keywordflow">return</span> os.str();
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a12026d9abf82ced3faf37d6b8e4b95d3"></a><!-- doxytag: member="lilc_matrix::first" ref="a12026d9abf82ced3faf37d6b8e4b95d3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d5f46926a479b2ca4c75a5d6f01bccb"></a><!-- doxytag: member="lilc_matrix::list" ref="a4d5f46926a479b2ca4c75a5d6f01bccb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::deque&lt; int &gt; &gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#a4d5f46926a479b2ca4c75a5d6f01bccb">list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/<a class="el" href="lilc__matrix__declarations_8h_source.html">lilc_matrix_declarations.h</a></li>
<li>source/<a class="el" href="lilc__matrix__ildl_8h_source.html">lilc_matrix_ildl.h</a></li>
<li>source/<a class="el" href="lilc__matrix__load_8h_source.html">lilc_matrix_load.h</a></li>
<li>source/<a class="el" href="lilc__matrix__pivot_8h_source.html">lilc_matrix_pivot.h</a></li>
<li>source/<a class="el" href="lilc__matrix__save_8h_source.html">lilc_matrix_save.h</a></li>
<li>source/<a class="el" href="lilc__matrix__to__string_8h_source.html">lilc_matrix_to_string.h</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 19 2012 09:53:34 for matrix-factor by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
