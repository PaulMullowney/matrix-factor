<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>matrix-factor: lilc_matrix&lt; el_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">matrix-factor&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">Incomplete LDL' factorizations of indefinite symmetric matrices.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">lilc_matrix&lt; el_type &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="lilc_matrix" --><!-- doxytag: inherits="lil_sparse_matrix" -->
<p>A list-of-lists (LIL) matrix in column oriented format.  
 <a href="classlilc__matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lilc__matrix__declarations_8h_source.html">lilc_matrix_declarations.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lilc_matrix&lt; el_type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix__inherit__graph.png" border="0" usemap="#lilc__matrix_3_01el__type_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="lilc__matrix_3_01el__type_01_4_inherit__map" id="lilc__matrix_3_01el__type_01_4_inherit__map">
<area shape="rect" id="node2" href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices." alt="" coords="5,5,203,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for lilc_matrix&lt; el_type &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix__coll__graph.png" border="0" usemap="#lilc__matrix_3_01el__type_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="lilc__matrix_3_01el__type_01_4_coll__map" id="lilc__matrix_3_01el__type_01_4_coll__map">
<area shape="rect" id="node2" href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices." alt="" coords="198,96,396,123"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classlilc__matrix-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a><br class="typebreak"/>
&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">idx_vector_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a><br class="typebreak"/>
&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">elt_vector_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef idx_vector_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef elt_vector_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#acdaad0931ff27d7bfc361d3033713914">lilc_matrix</a> (int n_rows=0, int n_cols=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a column oriented list-of-lists (LIL) matrix. Space for both the values list and the indices list of the matrix is allocated here.  <a href="#acdaad0931ff27d7bfc361d3033713914"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual el_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a> (const int &amp;i, const int &amp;j, int offset=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the (i,j)th coefficient of the matrix.  <a href="#a0e59d373ec514c8cb264da653d36f753"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">coeffRef</a> (const int &amp;i, const int &amp;j, std::pair&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a>, <a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> &gt; &amp;its)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index/value pointers to (i,j)th coefficient of the matrix.  <a href="#a327c165f0c90cd362dd14fc6421ebadd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">resize</a> (int n_rows, int n_cols)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix. For use in preallocating space before factorization begins.  <a href="#aca815e0ac073abb1e6ef888b09f9e795"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a46161695c5bfb0f43a7dedb9b9146fef">find_root</a> (int &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pseudo-peripheral root of A. This is essentially many chained breadth-first searchs across the graph of A (where A is viewed as an adjacency matrix).  <a href="#a46161695c5bfb0f43a7dedb9b9146fef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5">find_level_set</a> (vector&lt; int &gt; &amp;lvl_set, vector&lt; bool &gt; &amp;visited)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next level set given the current level set of A. This is essentially all neighbours of the currently enqueued nodes in breath-first search.  <a href="#ad343cd9b2f435f40a9866de050f63ce5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ab34914d2b48a5bf14e7ef22e89d2f2e7">sym_rcm</a> (vector&lt; int &gt; &amp;perm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Reverse Cuthill-McKee ordering of the matrix A (stored in perm).  <a href="#ab34914d2b48a5bf14e7ef22e89d2f2e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#af72f55f6880cef04205eb3df7018bce9">sym_perm</a> (vector&lt; int &gt; &amp;perm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a permutation vector perm, A is permuted to P'AP, where P is the permutation matrix associated with perm.  <a href="#af72f55f6880cef04205eb3df7018bce9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a37fc8dcc40799dfde0decaaf8bd74b51">sym_equil</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A, where S is a diagonal scaling matrix.  <a href="#a37fc8dcc40799dfde0decaaf8bd74b51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a121e606e3fe15ae0257fd87bef7cf320">ildl</a> (<a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;L, <a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;D, <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;perm, const double &amp;fill_factor, const double &amp;tol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an LDL' factorization of this matrix.  <a href="#a121e606e3fe15ae0257fd87bef7cf320"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c">pivot</a> (<a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt; s, vector&lt; bool &gt; &amp;in_set, <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;L, const int &amp;k, const int &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symmetric permutation between row/col k &amp; r of A.  <a href="#ad2c9a672941d6b47d3c60f631d21078c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2">ensure_invariant</a> (const int &amp;j, const int &amp;k, Container &amp;con, bool update_list=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures two the invariants observed by A.first and A.list are held.  <a href="#aea44b3b7358782ffe30f703b3f738aa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a> (const int &amp;k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates A.first for iteration k.  <a href="#a177dde39764c88fe4e82b050a5e60303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a> (const int &amp;k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates A.list for iteration k.  <a href="#ab9ee09328b84657630f52631ea8e5eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a60c5a4a0ec9a49d43be087b6d67f4df2">to_string</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of A, with each column and its corresponding indices &amp; non-zero values printed.  <a href="#a60c5a4a0ec9a49d43be087b6d67f4df2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aea5613e9a57231a6991dcf99d6d7b37a">load</a> (std::string filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a matrix in matrix market format.  <a href="#aea5613e9a57231a6991dcf99d6d7b37a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#aad2918af411cbef86995537f646fc2ae">save</a> (std::string filename, bool sym)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a matrix in matrix market format.  <a href="#aad2918af411cbef86995537f646fc2ae"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may swap between two rows, we require linked lists for each row of A.  <a href="#ad942a0e5503a2b4327a12287432fca81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i, k).  <a href="#a12026d9abf82ced3faf37d6b8e4b95d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the <a class="el" href="classlilc__matrix.html#a37fc8dcc40799dfde0decaaf8bd74b51" title="The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A...">sym_equil()</a> function, after which SAS will be stored in place of A.  <a href="#afc4659265addfeab376ffaa8f54ed596"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class el_type&gt;<br/>
class lilc_matrix&lt; el_type &gt;</h3>

<p>A list-of-lists (LIL) matrix in column oriented format. </p>
<p>For convience, the matrix this class represents will be refered to as matrix A. In LIL-C format, each column of A (an n*n matrix) is stored as a separate vector. The nonzeros are stored in m_idx while the non-zeros are stored in m_x. Both m_x and m_idx are initialized to a list of n lists. m_idx and m_x are ordered dependent on each other, in that A(m_idx[k][j], k) = m_x[k][j]. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ad34c37b7095e283a7e5d7160fe26fd1b"></a><!-- doxytag: member="lilc_matrix::elt_it" ref="ad34c37b7095e283a7e5d7160fe26fd1b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef elt_vector_type::iterator <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5a7b6e31a6c9ebf2ea3a898fe646af6"></a><!-- doxytag: member="lilc_matrix::elt_vector_type" ref="aa5a7b6e31a6c9ebf2ea3a898fe646af6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a>&lt;el_type&gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a> <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">elt_vector_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classlil__sparse__matrix.html#aac442ebc44706f184c7ce4ee7e1fdd6d">lil_sparse_matrix&lt; el_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8cd399b5bc0ef50dcf5a59a671e32248"></a><!-- doxytag: member="lilc_matrix::idx_it" ref="a8cd399b5bc0ef50dcf5a59a671e32248" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef idx_vector_type::iterator <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a83c70482c28275881562ee3937b5f591"></a><!-- doxytag: member="lilc_matrix::idx_vector_type" ref="a83c70482c28275881562ee3937b5f591" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a>&lt;el_type&gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">lil_sparse_matrix&lt; el_type &gt;</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acdaad0931ff27d7bfc361d3033713914"></a><!-- doxytag: member="lilc_matrix::lilc_matrix" ref="acdaad0931ff27d7bfc361d3033713914" args="(int n_rows=0, int n_cols=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html">lilc_matrix</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for a column oriented list-of-lists (LIL) matrix. Space for both the values list and the indices list of the matrix is allocated here. </p>
<div class="fragment"><pre class="fragment">                                                    : 
        <a class="code" href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices.">lil_sparse_matrix&lt;el_type&gt;</a> (<a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>) 
        {
                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>.reserve(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);
                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>.reserve(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph.png" border="0" usemap="#classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph" alt=""/></div>
<map name="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph" id="classlilc__matrix_acdaad0931ff27d7bfc361d3033713914_cgraph">
<area shape="rect" id="node3" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d" title="lil_sparse_matrix::n_cols" alt="" coords="206,5,381,32"/></map>
</div>
</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a177dde39764c88fe4e82b050a5e60303"></a><!-- doxytag: member="lilc_matrix::advance_first" ref="a177dde39764c88fe4e82b050a5e60303" args="(const int &amp;k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::advance_first </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates A.first for iteration k. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>current iteration index. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                                {
                <span class="keywordtype">int</span> offset;
                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].end(); it++) {    
                        <span class="comment">//ensure invariant (perhaps not needed here since the invariant is always ensured during pivoting).</span>
                        offset = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[*it];

                        <span class="keywordflow">if</span> (offset &gt;= (<span class="keywordtype">int</span>) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it].size()) <span class="keywordflow">continue</span>;
                        
                        <a class="code" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held.">ensure_invariant</a>(*it, k, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it]);
                        
                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it][offset] == k)
                                <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[*it]++;
                }
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph.png" border="0" usemap="#classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph" alt=""/></div>
<map name="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph" id="classlilc__matrix_a177dde39764c88fe4e82b050a5e60303_cgraph">
<area shape="rect" id="node3" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held." alt="" coords="229,5,424,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab9ee09328b84657630f52631ea8e5eb1"></a><!-- doxytag: member="lilc_matrix::advance_list" ref="ab9ee09328b84657630f52631ea8e5eb1" args="(const int &amp;k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::advance_list </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates A.list for iteration k. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>current iteration index. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                               {
                        <span class="keywordtype">int</span> offset;
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].begin(); it != <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].end(); it++) {
                                offset = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[*it];

                                <span class="keywordflow">if</span> (offset &gt;= (<span class="keywordtype">int</span>) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].size()) <span class="keywordflow">continue</span>;
                                
                                <a class="code" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held.">ensure_invariant</a>(*it, k, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it], <span class="keyword">true</span>);
                                
                                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it][offset] == k)
                                        <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[*it]++;
                        }
                                        
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph.png" border="0" usemap="#classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph" alt=""/></div>
<map name="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph" id="classlilc__matrix_ab9ee09328b84657630f52631ea8e5eb1_cgraph">
<area shape="rect" id="node3" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held." alt="" coords="224,5,419,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0e59d373ec514c8cb264da653d36f753"></a><!-- doxytag: member="lilc_matrix::coeff" ref="a0e59d373ec514c8cb264da653d36f753" args="(const int &amp;i, const int &amp;j, int offset=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual el_type <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::coeff </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the (i,j)th coefficient of the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">offset</td><td>an optional search offset for use in linear search (start at offset instead of 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The (i,j)th element of the matrix. </dd></dl>

<p>Implements <a class="el" href="classlil__sparse__matrix.html#a03af482b9f3d8c8b522dd5e49a2500ee">lil_sparse_matrix&lt; el_type &gt;</a>.</p>
<div class="fragment"><pre class="fragment">        {       
                <span class="comment">//invariant: first elem in each col of a is the diagonal elem if it exists.</span>
                <span class="keywordflow">if</span> (i == j) {
                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j].size() == 0) <span class="keywordflow">return</span> 0;
                        <span class="keywordflow">return</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j][0] == i ? <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j][0] : 0);
                }
                
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = offset, end = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j].size(); k &lt; end; k++) {
                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j][k] == i) <span class="keywordflow">return</span> <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j][k];
                }
                
                <span class="keywordflow">return</span> 0;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a327c165f0c90cd362dd14fc6421ebadd"></a><!-- doxytag: member="lilc_matrix::coeffRef" ref="a327c165f0c90cd362dd14fc6421ebadd" args="(const int &amp;i, const int &amp;j, std::pair&lt; idx_it, elt_it &gt; &amp;its)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::coeffRef </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classlilc__matrix.html#a8cd399b5bc0ef50dcf5a59a671e32248">idx_it</a>, <a class="el" href="classlilc__matrix.html#ad34c37b7095e283a7e5d7160fe26fd1b">elt_it</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>its</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the index/value pointers to (i,j)th coefficient of the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">its</td><td>a pair of pointers, one for the index of the found element, and the other for the value of the element. If the element is not found, the pointers point to the end of column j.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if (i,j)th element is nonzero, false otherwise. </dd></dl>
<div class="fragment"><pre class="fragment">        {       
                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j].size(); k++) {
                        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j][k] == i) {
                                its = make_pair(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j].begin() + k, <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j].begin() + k);
                                <span class="keywordflow">return</span> <span class="keyword">true</span>;
                        }
                }
                
                its = make_pair(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j].end(), <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j].end());
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
</pre></div>
</div>
</div>
<a class="anchor" id="aea44b3b7358782ffe30f703b3f738aa2"></a><!-- doxytag: member="lilc_matrix::ensure_invariant" ref="aea44b3b7358782ffe30f703b3f738aa2" args="(const int &amp;j, const int &amp;k, Container &amp;con, bool update_list=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ensure_invariant </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_list</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensures two the invariants observed by A.first and A.list are held. </p>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>If this matrix is a lower triangular factor of another matrix:<ol type="1">
<li>On iteration k, first[i] will give the number of non-zero elements on col i of A before A(i, k).</li>
<li>On iteration k, list[i][ first[i] ] will contain the first element below or on index k of column i of A.</li>
</ol>
</dd>
<dd>
If this matrix is the matrix to be factored:<ol type="1">
<li>On iteration k, first[i] will give the number of non-zero elements on row i of A before A(i, k).</li>
<li>On iteration k, list[i][ first[i] ] will contain the first element right of or on index k of row i of A.</li>
</ol>
</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>the column of con. </td></tr>
    <tr><td class="paramname">k</td><td>the iteration number. </td></tr>
    <tr><td class="paramname">con</td><td>the container to be swapped. </td></tr>
    <tr><td class="paramname">update_list</td><td>boolean indicating whether list or m_x/m_idx should be updated. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                                                                                           {
                <span class="keywordtype">int</span> offset = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[j];
                <span class="keywordflow">if</span> ((offset &gt;= (<span class="keywordtype">int</span>) con.size()) || con.empty() || con[offset] == k) <span class="keywordflow">return</span>;
                
                <span class="keywordtype">int</span> i, min(offset);
                <span class="keywordflow">for</span> (i = offset; i &lt; (int) con.size(); i++) {
                        <span class="keywordflow">if</span> (con[i] == k) {
                                min = i; 
                                <span class="keywordflow">break</span>;
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( con[i] &lt; con[min] ) {
                                min = i;
                        }
                }
                
                <span class="keywordflow">if</span> (update_list)
                        std::swap(con[offset], con[min]);
                <span class="keywordflow">else</span> {
                        std::swap(con[offset], con[min]);
                        std::swap(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j][offset], <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j][min]);
                }
        }
</pre></div>
</div>
</div>
<a class="anchor" id="ad343cd9b2f435f40a9866de050f63ce5"></a><!-- doxytag: member="lilc_matrix::find_level_set" ref="ad343cd9b2f435f40a9866de050f63ce5" args="(vector&lt; int &gt; &amp;lvl_set, vector&lt; bool &gt; &amp;visited)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::find_level_set </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>lvl_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next level set given the current level set of A. This is essentially all neighbours of the currently enqueued nodes in breath-first search. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lvl_set</td><td>the current level set (a list of nodes). </td></tr>
    <tr><td class="paramname">visited</td><td>all previously visited nodes. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                                                                              {
        vector&lt;int&gt; new_set;
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> node_it = lvl_set.begin(); node_it != lvl_set.end(); node_it++) {

                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*node_it].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*node_it].end(); it++) {
                        <span class="keywordflow">if</span> (!visited[*it]) {
                                visited[*it] = <span class="keyword">true</span>;
                                new_set.push_back(*it);
                        }
                }
                
                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*node_it].begin(); it != <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*node_it].end(); it++) {
                        <span class="keywordflow">if</span> (!visited[*it]) {
                                visited[*it] = <span class="keyword">true</span>;
                                new_set.push_back(*it);
                        }
                }
        }
        
        <span class="keywordflow">if</span> (new_set.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        
        lvl_set.swap(new_set);
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a46161695c5bfb0f43a7dedb9b9146fef"></a><!-- doxytag: member="lilc_matrix::find_root" ref="a46161695c5bfb0f43a7dedb9b9146fef" args="(int &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::find_root </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pseudo-peripheral root of A. This is essentially many chained breadth-first searchs across the graph of A (where A is viewed as an adjacency matrix). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>contains the initial node to seed the algorithm. A pseudo-peripheral root of A is stored in s at the end of the algorithm. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                                    {
        vector&lt;bool&gt; visited(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>, <span class="keyword">false</span>);
        vector&lt;int&gt; lvl_set;
        <span class="keywordtype">int</span> ls_max = 0, ls = 0;
        
        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
                lvl_set.clear();
                std::fill(visited.begin(), visited.end(), <span class="keyword">false</span>);
                ls = 0;
                
                lvl_set.push_back(s);
                visited[s] = <span class="keyword">true</span>;
                <span class="keywordflow">while</span> (<a class="code" href="classlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5" title="Returns the next level set given the current level set of A. This is essentially all neighbours of th...">find_level_set</a>(lvl_set, visited))
                        ls++;

                <span class="keywordflow">if</span> (ls &gt; ls_max) {
                        ls_max = ls;
                        <span class="keywordtype">int</span> deg, min_deg = <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>;
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = lvl_set.begin(); it != lvl_set.end(); it++) {
                                deg = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].size() + <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it].size();
                                <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it].size() &gt; 0 &amp;&amp; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it][0] == *it) deg--;
                                <span class="keywordflow">if</span> (deg &lt; min_deg) { <span class="comment">//should consider tie breaking by index later if needed.</span>
                                        min_deg = deg;
                                        s = *it;
                                }
                        }
                } <span class="keywordflow">else</span> {
                        <span class="keywordflow">break</span>;
                }
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a121e606e3fe15ae0257fd87bef7cf320"></a><!-- doxytag: member="lilc_matrix::ildl" ref="a121e606e3fe15ae0257fd87bef7cf320" args="(lilc_matrix&lt; el_type &gt; &amp;L, block_diag_matrix&lt; el_type &gt; &amp;D, idx_vector_type &amp;perm, const double &amp;fill_factor, const double &amp;tol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ildl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlil__sparse__matrix.html#aac6d12fd87c19ad7d39f0fbdf7e0aa01">idx_vector_type</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>fill_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs an LDL' factorization of this matrix. </p>
<p>The pivoted matrix P'AP will be stored in place of A. In addition, the L and D factors of P'AP will be stored in L and D (so that P'AP = LDL'). The factorization is performed in crout order and follows the algorithm outlined in "Crout versions of the ILU factorization with pivoting for sparse symmetric matrices" by Li and Saad (2005).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>the L factor of this matrix. </td></tr>
    <tr><td class="paramname">D</td><td>the D factor of this matrix. </td></tr>
    <tr><td class="paramname">perm</td><td>the current permutation of A. </td></tr>
    <tr><td class="paramname">fill_factor</td><td>a parameter to control memory usage. Each column is guaranteed to have fewer than fill_factor*(nnz(A)/n_col(A)) elements. </td></tr>
    <tr><td class="paramname">tol</td><td>a parameter to control agressiveness of dropping. In each column, elements less than tol*norm(column) are dropped. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{

        <span class="comment">//----------------- initialize temporary variables --------------------//</span>
        <span class="keywordtype">int</span> lfil = 2*fill_factor*<a class="code" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a>()/<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(); <span class="comment">//roughly a factor of 2 since only lower tri. of A is stored</span>
        <span class="keyword">const</span> el_type alpha = (1.0+sqrt(17.0))/8.0;  <span class="comment">//for use in pivoting.</span>
        el_type w1, wr, d1, dr(-1);
        el_type det_D, D_inv11, D_inv22, D_inv12;
        el_type l_11, l_12;

        <span class="keyword">const</span> <span class="keywordtype">int</span> ncols = <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(); <span class="comment">//number of cols in A.</span>

        vector&lt;bool&gt; in_set(ncols, <span class="keyword">false</span>); <span class="comment">//bitset used for unsorted merges</span>
        <a class="code" href="classswap__struct.html" title="A structure containing variables used in pivoting a LIL-C matrix.">swap_struct&lt;el_type&gt;</a> s; <span class="comment">//struct containing temp vars used in pivoting.</span>
        
        <a class="code" href="classlilc__matrix.html#aa5a7b6e31a6c9ebf2ea3a898fe646af6">elt_vector_type</a> work(ncols, 0), temp(ncols, 0); 
        <a class="code" href="classlilc__matrix.html#a83c70482c28275881562ee3937b5f591">idx_vector_type</a> curr_nnzs, temp_nnzs;  <span class="comment">//non-zeros on current col.</span>
        curr_nnzs.reserve(ncols); <span class="comment">//reserves space for worse case (entire col is non-zero)</span>

        <span class="keywordtype">int</span> count = 0; <span class="comment">//the total number of nonzeros stored in L.</span>
        <span class="keywordtype">int</span> i, j, k, r, offset, col_size, col_size2(-1);
        <span class="keywordtype">bool</span> size_two_piv = <span class="keyword">false</span>;      <span class="comment">//boolean indicating if the pivot is 2x2 or 1x1</span>

        <span class="comment">//--------------- allocate memory for L and D ------------------//</span>
        L.<a class="code" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795" title="Resizes the matrix. For use in preallocating space before factorization begins.">resize</a>(ncols, ncols);
        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>.resize(ncols ); <span class="comment">//allocate a vector of size n for Llist.</span>
        D.<a class="code" href="classblock__diag__matrix.html#a12249531555506377724ff14abec6905" title="Resizes this matrix to an n*n matrix.">resize</a>(ncols );
        

        <span class="keywordtype">int</span> debug = -1;
        
        <span class="comment">//------------------- main loop: factoring begins -------------------------//</span>
        <span class="keywordflow">for</span> (k = 0; k &lt; ncols; k++) {

                <span class="comment">//zero out work vector</span>
                curr_nnzs.clear();

                <span class="keywordflow">if</span> (k == debug) { 
                        cout &lt;&lt; <span class="stringliteral">&quot;m_idx[k]: &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k] &lt;&lt; endl;
                        cout &lt;&lt; <span class="stringliteral">&quot;m_x[k]: &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k] &lt;&lt; endl;
                }
                
                <span class="comment">//assign nonzeros indices of A(k:n, k) to curr_nnzs</span>
                curr_nnzs.assign (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].end());

                <span class="comment">//assign nonzero values of A(k:n, k) to work</span>
                <span class="keywordflow">for</span> (j = 0; j &lt; (int) curr_nnzs.size(); j++) {
                        work[curr_nnzs[j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k][j];
                }

                <span class="comment">//--------------begin pivoting--------------//</span>

                <span class="comment">//do delayed updates on current column. work = Sum_{i=0}^{k-1} L(k,i) * D(i,i) * L(k:n, i)</span>
                <span class="comment">//(the formula above generalizes to block matrix form in the case of 2x2 pivots).</span>
                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ad05d288ce2ed4291f9463a4861487f01" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs.">update</a>(k, work, curr_nnzs, L, D, in_set);
                
                <span class="comment">//store diagonal element in d1. set diagonal element in work vector to 0</span>
                <span class="comment">//since we want to find the maximum off-diagonal element.</span>
                d1 = work[k];
                work[k] = 0;

                <span class="comment">//find maximum element in work and store its index in r.</span>
                w1 = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index.">max</a>(work, curr_nnzs, r);

                <span class="keywordflow">if</span> (k == debug) { 
                        cout &lt;&lt; <span class="stringliteral">&quot;curr_nnzs: &quot;</span> &lt;&lt; curr_nnzs &lt;&lt; endl;
                        <span class="keywordflow">for</span> (i = 0; i &lt; (int) curr_nnzs.size(); i++) {
                                cout &lt;&lt; work[curr_nnzs[i]] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
                        }
                        cout &lt;&lt; endl;
                        cout &lt;&lt; <span class="stringliteral">&quot;w1: &quot;</span> &lt;&lt; w1 &lt;&lt; endl;
                }
                
                <span class="comment">//bunch-kaufman partial pivoting is used below. for a more detailed reference,</span>
                <span class="comment">//refer to &quot;Accuracy and Stability of Numerical Algorithms.&quot; by Higham (2002).</span>
                <span class="comment">//------------------- begin bunch-kaufman pivoting ------------------//</span>
                <span class="keywordflow">if</span> (w1 &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) {
                        <span class="comment">//case 0: do nothing. pivot is k.</span>
                        <span class="keywordflow">if</span> (k == debug) {
                                cout &lt;&lt; <span class="stringliteral">&quot;case 0&quot;</span> &lt;&lt; endl;
                        }
                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (alpha * w1 - abs(d1)) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>  ) {
                        <span class="comment">//case 1: do nothing. pivot is k.</span>
                        <span class="keywordflow">if</span> (k == debug) {
                                cout &lt;&lt; <span class="stringliteral">&quot;case 1&quot;</span> &lt;&lt; endl;
                        }
                } <span class="keywordflow">else</span> {
                        <span class="comment">//zero out temp vector.</span>
                        temp_nnzs.clear();

                        offset = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[r];
                        <span class="comment">//assign all nonzero indices and values in A(r, k:r) </span>
                        <span class="comment">//( not including A(r,r) ) to temp and temp_nnzs</span>
                        <span class="keywordflow">for</span> (j = offset; j &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].size(); j++) {
                                temp_nnzs.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r][j]);
                                temp[<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r][j]] = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753" title="Finds the (i,j)th coefficient of the matrix.">coeff</a>(r, list[r][j]);
                        }

                        <span class="comment">//assign nonzero indices of A(r:n, r) to temp_nnzs </span>
                        temp_nnzs.insert(temp_nnzs.end(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].begin(), <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].end());

                        <span class="comment">//assign nonzero values of to temp</span>
                        <span class="keywordflow">for</span> (j = 0; j &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].size(); j++) {
                                temp[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r][j]] = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[r][j];
                        }

                        <span class="comment">//perform delayed updates on temp. temp = Sum_{i=0}^{k-1} L(r,i) * D(i,i) * L(k:n, i).</span>
                        <span class="comment">//(the formula above generalizes to block matrix form in the case of 2x2 pivots).</span>
                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ad05d288ce2ed4291f9463a4861487f01" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs.">update</a>(r, temp, temp_nnzs, L, D, in_set);

                        dr = temp[r];
                        temp[r] = 0;

                        <span class="comment">//find maximum element in temp.</span>
                        wr = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index.">max</a>(temp, temp_nnzs, j);

                        <span class="keywordflow">if</span> ((alpha*w1*w1 - abs(d1)*wr) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) {
                                <span class="comment">//case 2: do nothing. pivot is k.</span>
                                <span class="keywordflow">if</span> (k == debug) {
                                        cout &lt;&lt; <span class="stringliteral">&quot;case 2&quot;</span> &lt;&lt; endl;
                                        cout &lt;&lt; <span class="stringliteral">&quot;d1: &quot;</span> &lt;&lt; d1 &lt;&lt; <span class="stringliteral">&quot; wr: &quot;</span> &lt;&lt; wr &lt;&lt; <span class="stringliteral">&quot; w1: &quot;</span> &lt;&lt; w1 &lt;&lt; endl;
                                }
                                
                                
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (alpha * wr - abs(dr)) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) {
                                <span class="comment">//case 3: pivot is k with r: 1x1 pivot case.</span>
                                temp[r] = dr;
                                work[k] = d1;

                                <span class="keywordflow">if</span> (k &gt; r) {
                                        cout &lt;&lt; <span class="stringliteral">&quot;case 3 &quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;
                                        cout &lt;&lt; <span class="stringliteral">&quot;fault! &quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;
                                        <span class="keywordflow">return</span>;
                                }

                                <span class="comment">//--------pivot A and L ---------//</span>
                                <a class="code" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c" title="Performs a symmetric permutation between row/col k &amp; r of A.">pivot</a>(s, in_set, L, k, r);

                                <span class="comment">//----------pivot rest ----------//</span>
                                std::swap(d1, dr);

                                <span class="comment">//permute perm</span>
                                std::swap(perm[k], perm[r]);

                                work.swap(temp);        <span class="comment">//swap work with temp.</span>
                                std::swap(work[k], work[r]); <span class="comment">//swap kth and rth row of work</span>

                                curr_nnzs.swap(temp_nnzs);      <span class="comment">//swap curr_nnzs with temp_nnzs</span>

                                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ac6f821ca233295dd508731797ed4d954">safe_swap</a>(curr_nnzs, k, r); <span class="comment">//swap k and r if they are present in curr_nnzs</span>

                                <span class="comment">//--------end pivot rest---------//</span>

                        } <span class="keywordflow">else</span> {
                                <span class="comment">//case 4: pivot is k+1 with r: 2x2 pivot case.</span>
                                <span class="keywordflow">if</span> (k == debug) {
                                        cout &lt;&lt; <span class="stringliteral">&quot;case 4&quot;</span> &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; k+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;
                                        cout &lt;&lt; <span class="stringliteral">&quot;temp_nnzs: &quot;</span> &lt;&lt; temp_nnzs &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;
                                        <span class="keywordflow">for</span> (i = 0; i &lt; (int) temp_nnzs.size(); i++) {
                                                cout &lt;&lt; temp[temp_nnzs[i]] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
                                        }
                                        cout &lt;&lt; endl;
                                }
                                <span class="keywordflow">if</span> (k &gt;= r) {
                                        cout &lt;&lt; <span class="stringliteral">&quot;fault! &quot;</span> &lt;&lt; k+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;
                                        <span class="keywordflow">return</span>;
                                }

                                <span class="comment">//must advance list for 2x2 pivot since we are pivoting on col k+1</span>
                                <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1" title="Updates A.list for iteration k.">advance_list</a>(k);
                                <span class="comment">//for the same reason as above, we must advance L.first as well</span>
                                L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303" title="Updates A.first for iteration k.">advance_first</a>(k);

                                <span class="comment">//restore diagonal elements in work and temp</span>
                                temp[r] = dr;
                                work[k] = d1;

                                <span class="comment">//indicate that pivot is 2x2</span>
                                size_two_piv = <span class="keyword">true</span>;

                                <span class="keywordflow">if</span> (k+1 != r) {
                                        <span class="comment">//symmetrically permute row/col k+1 and r.</span>
                                        <a class="code" href="classlilc__matrix.html#ad2c9a672941d6b47d3c60f631d21078c" title="Performs a symmetric permutation between row/col k &amp; r of A.">pivot</a>(s, in_set, L, k+1, r);


                                        <span class="comment">//----------pivot rest ----------//</span>

                                        <span class="comment">//permute perm</span>
                                        std::swap(perm[k+1], perm[r]);

                                        <span class="comment">//swap rows k+1 and r of work and temp</span>
                                        std::swap(work[k+1], work[r]);
                                        std::swap(temp[k+1], temp[r]);

                                        <span class="comment">//swap k+1 and r in curr_nnzs and temp_nnzs</span>
                                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ac6f821ca233295dd508731797ed4d954">safe_swap</a>(curr_nnzs, k+1, r);
                                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ac6f821ca233295dd508731797ed4d954">safe_swap</a>(temp_nnzs, k+1, r);
                                }
                        }
                }
                <span class="comment">//--------------end pivoting--------------//</span>

                <span class="comment">//erase diagonal element from non-zero indices (to exclude it from being dropped)</span>
                curr_nnzs.erase(std::remove(curr_nnzs.begin(), curr_nnzs.end(), k), curr_nnzs.end());

                <span class="comment">//performs the dual dropping procedure.</span>
                <span class="keywordflow">if</span> (!size_two_piv) {
                        <span class="comment">//perform dual dropping criteria on work</span>
                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a67cef3500c6f2df4556228bcb05e24ad" title="Performs the dual-dropping criteria outlined in Li &amp; Saad (2005).">drop_tol</a>(work, curr_nnzs, lfil, tol);

                } <span class="keywordflow">else</span> {
                        <span class="comment">//erase diagonal 2x2 block from non-zero indices (to exclude it from being dropped)</span>
                        temp_nnzs.erase(std::remove(temp_nnzs.begin(), temp_nnzs.end(), k), temp_nnzs.end());
                        curr_nnzs.erase(std::remove(curr_nnzs.begin(), curr_nnzs.end(), k+1), curr_nnzs.end());
                        temp_nnzs.erase(std::remove(temp_nnzs.begin(), temp_nnzs.end(), k+1), temp_nnzs.end());
                        
                        <span class="comment">//compute inverse of the 2x2 block diagonal pivot.</span>
                        det_D = d1*dr - work[k+1]*work[k+1];
                        <span class="keywordflow">if</span> ( abs(det_D) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) det_D = 1e-6;  <span class="comment">//statically pivot;</span>
                        D_inv11 = dr/det_D;
                        D_inv22 = d1/det_D;
                        D_inv12 = -work[k+1]/det_D;
                        
                        <span class="comment">//assign pivot to D (d1 is assigned to D(k,k) later)</span>
                        D.<a class="code" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3">off_diagonal</a>(k) = work[k+1];
                        D[k+1] = dr;
                        
                        <span class="comment">//merge nonzeros of curr and temp together so iterating through them will be easier</span>
                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65" title="Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list...">unordered_inplace_union</a>(curr_nnzs, temp_nnzs.begin(), temp_nnzs.end(), in_set);

                        
                        <span class="comment">//multiply inverse of pivot to work and temp (gives us two columns of l)</span>
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {
                                l_11 = work[*it]*D_inv11 + temp[*it]*D_inv12;
                                l_12 = work[*it]*D_inv12 + temp[*it]*D_inv22;
                                
                                <span class="comment">//note that work and temp roughly share the same non-zero indices</span>
                                work[*it] = l_11;
                                temp[*it] = l_12;
                        }
                        
                        <span class="comment">//since the work and temp non-zero indices are roughly the same,</span>
                        <span class="comment">//we can copy it over to temp_nnzs</span>
                        temp_nnzs.assign(curr_nnzs.begin(), curr_nnzs.end());
                        
                        <span class="comment">//perform dual dropping procedure on work and temp</span>
                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a67cef3500c6f2df4556228bcb05e24ad" title="Performs the dual-dropping criteria outlined in Li &amp; Saad (2005).">drop_tol</a>(temp, temp_nnzs, lfil, tol);
                        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a67cef3500c6f2df4556228bcb05e24ad" title="Performs the dual-dropping criteria outlined in Li &amp; Saad (2005).">drop_tol</a>(work, curr_nnzs, lfil, tol);
                        

                }

                <span class="comment">//resize kth column of L to proper size.</span>
                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].resize(curr_nnzs.size()+1);
                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k].resize(curr_nnzs.size()+1);
                
                <span class="comment">//assign diagonal element to D</span>
                D[k] = d1;
                
                <span class="comment">//assign 1s to diagonal of L.</span>
                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k][0] = 1;
                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k][0] = k;
                count++;
                
                <span class="keywordflow">if</span> (!size_two_piv) {
                        <span class="keywordflow">if</span> ( abs(D[k]) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) D[k] = 1e-6; <span class="comment">//statically pivot</span>
                        i = 0;
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) { 
                                <span class="keywordflow">if</span> ( abs(work[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) {
                                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k][i+1] = *it; <span class="comment">//col k nonzero indices of L are stored</span>
                                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k][i+1] = work[*it]/D[k]; <span class="comment">//col k nonzero values of L are stored</span>

                                        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].push_back(k); <span class="comment">//update Llist</span>
                                        count++;
                                        i++;
                                }
                        }
                        
                        col_size = 1 + i;
                        
                        <span class="comment">//advance list and L.first</span>
                        L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303" title="Updates A.first for iteration k.">advance_first</a>(k);
                        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1" title="Updates A.list for iteration k.">advance_list</a>(k);
                } <span class="keywordflow">else</span> {
                        <span class="comment">//resize k+1th column of L to proper size.</span>
                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k+1].resize(temp_nnzs.size()+1);
                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k+1].resize(temp_nnzs.size()+1);

                        <span class="comment">//assign 1s to diagonal of L.</span>
                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k+1][0] = 1;
                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k+1][0] = k+1;
                        count++;

                        i = 0;
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {
                                <span class="keywordflow">if</span> ( abs(work[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) {
                                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k][i+1] = work[*it]; <span class="comment">//col k nonzero indices of L are stored</span>
                                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k][i+1] = *it; <span class="comment">//col k nonzero values of L are stored</span>
                                        
                                        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].push_back(k); <span class="comment">//update L.list</span>
                                        count++;
                                        i++;
                                }
                                
                        }
                        
                        j = 0;
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = temp_nnzs.begin(); it != temp_nnzs.end(); it++) {
                                <span class="keywordflow">if</span> ( abs(temp[*it]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) {
                                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k+1][j+1] = temp[*it]; <span class="comment">//col k+1 nonzero indices of L are stored</span>
                                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k+1][j+1] = *it; <span class="comment">//col k+1 nonzero values of L are stored</span>
                                        
                                        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].push_back(k+1); <span class="comment">//update L.list</span>
                                        count++;
                                        j++;
                                }
                                
                        }

                        col_size = 1 + i;
                        col_size2 = 1 + j;

                        <span class="comment">//update list and L.first</span>
                        L.<a class="code" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303" title="Updates A.first for iteration k.">advance_first</a>(k+1);
                        <a class="code" href="classlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1" title="Updates A.list for iteration k.">advance_list</a>(k+1);
                        
                }
                
                <span class="comment">// ------------- reset temp and work back to zero -----------------//</span>
                work[k] = 0;
                temp[k] = 0;
                
                <span class="keywordflow">if</span> (k + 1 &lt; ncols) {
                        temp[k+1] = 0;
                        work[k+1] = 0;
                }
                
                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = curr_nnzs.begin(); it != curr_nnzs.end(); it++) {
                        work[*it] = 0;
                }
                curr_nnzs.clear();
                
                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = temp_nnzs.begin(); it != temp_nnzs.end(); it++) {
                        temp[*it] = 0;
                }
                temp_nnzs.clear();
                
                <span class="comment">//-------------------------------------------------------------------//</span>
                
                <span class="comment">//resize columns of L to correct size</span>
                L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k].resize(col_size);
                L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].resize(col_size);

                <span class="keywordflow">if</span> (size_two_piv) {
                        L.<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k+1].resize(col_size2);
                        L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k+1].resize(col_size2);
                        k++;
                        
                        size_two_piv = <span class="keyword">false</span>;
                }
                
                <span class="keywordflow">if</span> (k == debug) {
                        cout &lt;&lt; <span class="stringliteral">&quot;part of two piv? &quot;</span> &lt;&lt; size_two_piv &lt;&lt; endl;
                        cout &lt;&lt; <span class="stringliteral">&quot;lfil: &quot;</span> &lt;&lt; lfil &lt;&lt; endl;
                        cout &lt;&lt; <span class="stringliteral">&quot;D[k]: &quot;</span> &lt;&lt; D[k] &lt;&lt; endl;
                        cout &lt;&lt; <span class="stringliteral">&quot;D(k,k+1): &quot;</span> &lt;&lt; D.<a class="code" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3">off_diagonal</a>(k) &lt;&lt; endl;
                        cout &lt;&lt; <span class="stringliteral">&quot;D[k+1]: &quot;</span> &lt;&lt; D[k+1] &lt;&lt; endl;
                        
                        cout &lt;&lt; <span class="stringliteral">&quot;curr_nnzs: &quot;</span> &lt;&lt; curr_nnzs &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;
                        <span class="keywordflow">for</span> (i = 0; i &lt; col_size; i++) {
                                cout &lt;&lt; work[curr_nnzs[i]]/D[k] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
                        }
                        cout &lt;&lt; endl;
                }
                
                <span class="comment">// std::cout &lt;&lt; k &lt;&lt; std::endl;</span>
                <span class="comment">// std::string s;</span>
                <span class="comment">// std::cin &gt;&gt; s;</span>
                <span class="comment">// if (s == &quot;l&quot;) {</span>
                <span class="comment">// std::cout &lt;&lt; L &lt;&lt; std::endl;</span>
                <span class="comment">// } else if (s == &quot;a&quot;) {</span>
                <span class="comment">// std::cout &lt;&lt; to_string() &lt;&lt; std::endl;</span>
                <span class="comment">// } else if (s == &quot;w&quot;) {</span>
                        <span class="comment">// cout &lt;&lt; work &lt;&lt; endl;</span>
                <span class="comment">// } else if (s == &quot;t&quot;) {</span>
                        <span class="comment">// cout &lt;&lt; temp &lt;&lt; endl;</span>
                <span class="comment">// }</span>
                
        }

        <span class="comment">//assign number of non-zeros in L to L.nnz_count</span>
        L.<a class="code" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8" title="Number of nonzeros in the matrix.">nnz_count</a> = count;

}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a121e606e3fe15ae0257fd87bef7cf320_cgraph.png" border="0" usemap="#classlilc__matrix_a121e606e3fe15ae0257fd87bef7cf320_cgraph" alt=""/></div>
<map name="classlilc__matrix_a121e606e3fe15ae0257fd87bef7cf320_cgraph" id="classlilc__matrix_a121e606e3fe15ae0257fd87bef7cf320_cgraph">
<area shape="rect" id="node3" href="classlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303" title="Updates A.first for iteration k." alt="" coords="409,36,583,62"/><area shape="rect" id="node7" href="lilc__matrix__ildl__helpers_8h.html#a67cef3500c6f2df4556228bcb05e24ad" title="Performs the dual&#45;dropping criteria outlined in Li &amp; Saad (2005)." alt="" coords="212,48,287,74"/><area shape="rect" id="node9" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index." alt="" coords="225,98,273,125"/><area shape="rect" id="node11" href="classblock__diag__matrix.html#aa57572352da969e948428ad7521a1ce3" title="block_diag_matrix::off_diagonal" alt="" coords="387,250,605,277"/><area shape="rect" id="node13" href="classblock__diag__matrix.html#a12249531555506377724ff14abec6905" title="Resizes this matrix to an n*n matrix." alt="" coords="160,200,339,226"/><area shape="rect" id="node15" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795" title="Resizes the matrix. For use in preallocating space before factorization begins." alt="" coords="185,149,313,176"/><area shape="rect" id="node21" href="lilc__matrix__ildl__helpers_8h.html#ac6f821ca233295dd508731797ed4d954" title="safe_swap" alt="" coords="204,301,295,328"/><area shape="rect" id="node23" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65" title="Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list..." alt="" coords="659,352,842,378"/><area shape="rect" id="node25" href="lilc__matrix__ildl__helpers_8h.html#ad05d288ce2ed4291f9463a4861487f01" title="Performs a delayed update of subcolumn A(k+1:n,k). Result is stored in work vector. Nonzero elements of the work vector are stored in curr_nnzs." alt="" coords="217,352,282,378"/><area shape="rect" id="node5" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held." alt="" coords="653,250,848,277"/><area shape="rect" id="node17" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d" title="lil_sparse_matrix::n_cols" alt="" coords="409,124,583,150"/><area shape="rect" id="node19" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0" title="lil_sparse_matrix::n_rows" alt="" coords="406,174,586,201"/><area shape="rect" id="node27" href="classblock__diag__matrix.html#ad2a00befe5b5c5718e222fa99cbbefd2" title="block_diag_matrix::block_size" alt="" coords="393,402,599,429"/><area shape="rect" id="node29" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753" title="Finds the (i,j)th coefficient of the matrix." alt="" coords="435,352,557,378"/><area shape="rect" id="node32" href="lilc__matrix__ildl__helpers_8h.html#a237f9b0b8069cb75d0fd3cd4a55c9978" title="update_single" alt="" coords="441,301,551,328"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aea5613e9a57231a6991dcf99d6d7b37a"></a><!-- doxytag: member="lilc_matrix::load" ref="aea5613e9a57231a6991dcf99d6d7b37a" args="(std::string filename)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a matrix in matrix market format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be loaded. Must be in matrix market format (.mtx). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
        std::ifstream input(filename.c_str(), std::ios::in);

        <span class="keywordflow">if</span>(!input) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        
        <span class="keyword">const</span> <span class="keywordtype">int</span> maxBuffersize = 2048;
        <span class="keywordtype">char</span> buffer[maxBuffersize];

        <span class="keywordtype">bool</span> readsizes = <span class="keyword">false</span>;

        <span class="keywordtype">int</span> <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>(-1), <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(-1), n_nzs(-1), i(-1), j(-1);
        <span class="keywordtype">int</span> count = 0;
        el_type value; 

        <span class="keywordflow">while</span>(input.getline(buffer, maxBuffersize))
        {
                <span class="comment">// skip comments   </span>
                <span class="comment">//NOTE An appropriate test should be done on the header to get the symmetry</span>
                <span class="keywordflow">if</span>(buffer[0]==<span class="charliteral">&#39;%&#39;</span>)
                <span class="keywordflow">continue</span>;
                
                std::stringstream line(buffer);
                
                <span class="keywordflow">if</span>(!readsizes)
                {
                        line &gt;&gt; <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a> &gt;&gt; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a> &gt;&gt; n_nzs;
                        <span class="keywordflow">if</span>(<a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a> &gt; 0 &amp;&amp; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a> &gt; 0 &amp;&amp; n_nzs &gt; 0) 
                        {
                                readsizes = <span class="keyword">true</span>;
                                
                                <a class="code" href="classlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795" title="Resizes the matrix. For use in preallocating space before factorization begins.">resize</a>(<a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);
                                std::fill(<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>.begin(), <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>.end(), 0); <span class="comment">//a bit of optimization could be used here since resize sets all elem in first to 1</span>
                        }
                }
                <span class="keywordflow">else</span>
                { 
                        i = -1;
                        j = -1;
                        <span class="keywordflow">if</span>( <a class="code" href="lilc__matrix__load_8h.html#a6de8c02a91b0862a6d2221d4e8deb59e">readline</a>(line, <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>, i, j, value) ) 
                        {

                                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j].push_back(i);
                                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j].push_back(value);
                                ++count;
                                
                                <span class="keywordflow">if</span> (i != j) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[i].push_back(j);
                                
                        }
                        <span class="keywordflow">else</span> 
                        std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid read: &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;         
                }
                
        }
        
        <span class="keywordflow">if</span> (count != n_nzs) std::cout &lt;&lt; <span class="stringliteral">&quot;Expected &quot;</span> &lt;&lt; n_nzs &lt;&lt; <span class="stringliteral">&quot; elems but read &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; std::endl;
        
        <a class="code" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8" title="Number of nonzeros in the matrix.">nnz_count</a> = count;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Load succeeded. &quot;</span> &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; was loaded.&quot;</span> &lt;&lt; std::endl;
        input.close();
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph.png" border="0" usemap="#classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph" alt=""/></div>
<map name="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph" id="classlilc__matrix_aea5613e9a57231a6991dcf99d6d7b37a_cgraph">
<area shape="rect" id="node3" href="lilc__matrix__load_8h.html#a6de8c02a91b0862a6d2221d4e8deb59e" title="readline" alt="" coords="171,5,245,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad2c9a672941d6b47d3c60f631d21078c"></a><!-- doxytag: member="lilc_matrix::pivot" ref="ad2c9a672941d6b47d3c60f631d21078c" args="(swap_struct&lt; el_type &gt; s, vector&lt; bool &gt; &amp;in_set, lilc_matrix&lt; el_type &gt; &amp;L, const int &amp;k, const int &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::pivot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a symmetric permutation between row/col k &amp; r of A. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a struct containing temporary variables needed during pivoting. </td></tr>
    <tr><td class="paramname">in_set</td><td>a bitset needed for unordered unions during pivoting. </td></tr>
    <tr><td class="paramname">L</td><td>the lower triangular factor of A. </td></tr>
    <tr><td class="paramname">k</td><td>index of row/col k. </td></tr>
    <tr><td class="paramname">r</td><td>index of row/col r.</td></tr>
  </table>
  </dd>
</dl>
<p>There are four parts to this pivoting algorithm. For A, due to storing only the lower half, there are three steps to performing a symmetric permutation:</p>
<ol type="1">
<li>A(k, 1:k) must be swapped with A(r, 1:k) (row-row swap).</li>
<li>A(k:r, k) must be swapped with A(r, k:r) (row-column swap).</li>
<li>A(k:r, k) must be swapped with A(k:r, r) (column-column swap).</li>
</ol>
<p>For L, since column k and r are not yet formed, there is only one step (a row permutation):</p>
<ol type="1">
<li>L(k, 1:k) must be swapped with L(r, 1:k) (row-row swap). </li>
</ol>
<div class="fragment"><pre class="fragment">{       
        <span class="comment">//initialize temp variables</span>
        std::pair&lt;idx_it, elt_it&gt; its_k, its_r;
        <span class="keywordtype">int</span> i, j, idx, offset;
        
        <span class="comment">//----------- clear out old variables from last pivot -------------- //</span>
        <span class="comment">//for vectors of primitive types, clear is always constant time regardless of how many elements are in the container.</span>
        s.<a class="code" href="classswap__struct.html#ad97200ee23cd1f70668d6b4462228343" title="Clears all col vectors (col_k, col_r, col_k_nnzs, col_r_nnzs).">col_clear</a>();
        s.<a class="code" href="classswap__struct.html#a9727bf8ea70308977661235c59e3b8da" title="Clears all row vectors (row_k, row_r).">row_clear</a>();
        
        <span class="comment">//----------pivot A ----------//</span>
        s.<a class="code" href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581" title="Clears all swap vectors (swapk, swapr, all_swaps).">swap_clear</a>();
        
        <span class="comment">//------------- row-row swap (1) for A -------------//</span>
        
        <span class="comment">//pushes column indices (which contain non-zero elements) of A(k, 1:k) onto row_r</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].begin() + <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[k]; ++it) {
                s.<a class="code" href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427" title="Column indices of non-zeros in the new row r.">row_r</a>.push_back(*it);
        }
        
        <span class="comment">//pushes column indices (which contain non-zero elements) of A(r, 1:k) onto row_k</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].begin() + <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[r]; ++it) {
                s.<a class="code" href="classswap__struct.html#a52180e1635646cd4f2dab0209ae62cb9" title="Column indices of non-zeros in the new row k.">row_k</a>.push_back(*it);
        }
        
        <span class="comment">//merge these two sets of indices together</span>
        s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.assign(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].begin(), <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].begin() + <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[k]);
        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65" title="Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list...">unordered_inplace_union</a>(s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].begin(), <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].begin() + <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[r], in_set);
        
        <span class="comment">//do row swaps in A (i.e. swap A(k, 1:k) with A(r, 1:k))</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.begin(), end = s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.end(); it != end; ++it) {
                <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ac6f821ca233295dd508731797ed4d954">safe_swap</a>(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it], k, r);
        }
        s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.clear();
        
        <span class="comment">//----------------------------------------------------//</span>
        
        
        <span class="comment">//---------------------- (2) and (3) for A --------------------------//</span>
        
        <span class="comment">//after sym. perm, a_rr will be swapped to a_kk, so we put a_rr as first</span>
        <span class="comment">//elem of col k if its non-zero. this also means that we ensure the first</span>
        <span class="comment">//elem of col k is the diagonal element if it exists.</span>
        el_type elem = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753" title="Finds the (i,j)th coefficient of the matrix.">coeff</a>(r, r);
        <span class="keywordflow">if</span> (abs(elem) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>){
                s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71" title="Row indices of non-zeros in the new column k.">col_k_nnzs</a>.push_back(k);
                s.<a class="code" href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352" title="Non-zero values in the new column k (order dependent on col_k_nnzs).">col_k</a>.push_back(elem);
        }
        
        <span class="comment">//same as above, put a_kk in new col r if it exists.</span>
        elem = <a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753" title="Finds the (i,j)th coefficient of the matrix.">coeff</a>(k, k);
        <span class="keywordflow">if</span> (abs(elem) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>){
                s.<a class="code" href="classswap__struct.html#a8d4e30cd03fc142b81a332db04edc244" title="Row indices of non-zeros in the new column r.">col_r_nnzs</a>.push_back(r);
                s.<a class="code" href="classswap__struct.html#a3803a938141694098700de00d5cb6a7d" title="Non-zero values in the new column r (order dependent on col_r_nnzs).">col_r</a>.push_back(elem);
        }
        
        
        <span class="comment">//first[r] should have A(r, k:r)</span>
        <span class="keywordflow">for</span> (i = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[r]; i &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].size(); i++) {
                j = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r][i];
                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd" title="Finds the index/value pointers to (i,j)th coefficient of the matrix.">coeffRef</a>(r, j, its_k)) {
                        <span class="keywordflow">if</span> (j == k) {
                                s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71" title="Row indices of non-zeros in the new column k.">col_k_nnzs</a>.push_back(r); <span class="comment">//A(r, k) is fixed upon permutation so its index stays r</span>
                                s.<a class="code" href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427" title="Column indices of non-zeros in the new row r.">row_r</a>.push_back(k);
                        } <span class="keywordflow">else</span> {
                                s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71" title="Row indices of non-zeros in the new column k.">col_k_nnzs</a>.push_back(j); <span class="comment">//place A(r, i) (where k &lt; i &lt; r) into A(i, k)</span>
                        }
                        s.<a class="code" href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352" title="Non-zero values in the new column k (order dependent on col_k_nnzs).">col_k</a>.push_back(*its_k.second);
                        
                        <span class="comment">//delete A(r,i) from A.</span>
                        *its_k.first = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j].back();
                        *its_k.second = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j].back();
                        
                        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[j].pop_back();
                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[j].pop_back();
                }
        }

        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].size() &gt; 0) {
        
                <span class="comment">//place A(r:n, r) into A(r:n, k). since we already took care of A(r,r) above,</span>
                <span class="comment">//we need to offset by 1 if necessary.</span>
                offset = (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r][0] == r ? 1 : 0);
                std::copy(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[r].begin()+offset, <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[r].end(), std::back_inserter(s.<a class="code" href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352" title="Non-zero values in the new column k (order dependent on col_k_nnzs).">col_k</a>));
                std::copy(<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].begin()+offset, <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].end(), std::back_inserter(s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71" title="Row indices of non-zeros in the new column k.">col_k_nnzs</a>));

                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].begin() + offset; it != <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].end(); it++) {
                
                        <span class="comment">//for each non-zero row index in the rth column, find a pointer to it in list</span>
                        <span class="comment">//these pointers will be used to perform column swaps on list</span>
                        <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[*it] &lt; (<span class="keywordtype">int</span>) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].size())
                        <span class="keywordflow">for</span> (i = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[*it]; i &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].size(); i++) {
                                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it][i] == r) {
                                        s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9" title="List of indices from row r that will be swapped to row k.">swapk</a>.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].begin() + i);
                                        s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.push_back(*it);
                                        <span class="keywordflow">break</span>;
                                }
                        }
                }
        }

        <span class="comment">//swap A(k:r, k) with A(r, k:r)</span>
        <span class="keywordflow">if</span> (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].size() &gt; 0) {
                
                <span class="comment">//since we already too care of A(k,k), we need an offset of 1 if necessary</span>
                offset = (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k][0] == k ? 1 : 0);
                <span class="keywordflow">for</span> (i = offset; i &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].size(); i++) {
                        idx = <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k][i];
                        
                        <span class="comment">//if idx &lt; r, we are in (2) (row-col swap) otherwise we are in (3) (col-col swap)</span>
                        <span class="keywordflow">if</span> (idx &lt; r) {
                        
                                <span class="comment">//swap A(i, k) with A(r, i) where k &lt; i &lt; r.</span>
                                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[idx].push_back(r);        
                                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[idx].push_back(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k][i]);
                                
                                <span class="comment">//we also have to ensure that list is updated by popping off old entries</span>
                                <span class="comment">//that were meant for the A(i, k)&#39;s before they were swapped.</span>
                                <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[idx] &lt; (<span class="keywordtype">int</span>) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx].size()) {
                                        <a class="code" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held.">ensure_invariant</a>(idx, k, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx], <span class="keyword">true</span>);
                                        std::swap(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx][<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[idx]], <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx][<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx].size() - 1]);
                                        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx].pop_back();
                                }
                                
                                <span class="comment">//push back new elements on row_r</span>
                                s.<a class="code" href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427" title="Column indices of non-zeros in the new row r.">row_r</a>.push_back(idx);
                                
                        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (idx &gt; r) {
                        
                                <span class="comment">//swap A(i, k) with A(i, r) where r &lt; i.</span>
                                s.<a class="code" href="classswap__struct.html#a3803a938141694098700de00d5cb6a7d" title="Non-zero values in the new column r (order dependent on col_r_nnzs).">col_r</a>.push_back(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k][i]);
                                s.<a class="code" href="classswap__struct.html#a8d4e30cd03fc142b81a332db04edc244" title="Row indices of non-zeros in the new column r.">col_r_nnzs</a>.push_back(idx);
                                
                                <span class="comment">//for each non-zero row index in the kth column, find a pointer to it in list</span>
                                <span class="comment">//these pointers will be used to perform column swaps on list</span>
                                <span class="keywordflow">for</span> (j = <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[idx]; j &lt; (int) <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx].size(); j++) {
                                        <span class="keywordflow">if</span> (<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx][j] == k) {
                                                s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9" title="List of indices from row k that will be swapped to row r.">swapr</a>.push_back(<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[idx].begin() + j);
                                                s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.push_back(idx);
                                                <span class="keywordflow">break</span>;
                                        }
                                }
                        }
                }
        }

        <span class="comment">//swap all A(i, k) with A(i, r) in list.</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9" title="List of indices from row r that will be swapped to row k.">swapk</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9" title="List of indices from row r that will be swapped to row k.">swapk</a>.end(); it++) {
                **it = k;
        }
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9" title="List of indices from row k that will be swapped to row r.">swapr</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9" title="List of indices from row k that will be swapped to row r.">swapr</a>.end(); it++) {
                **it = r;
        }

        <span class="comment">//make sure invariant holds after all swaps.</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.begin(); it != s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.end(); it++) {
                <a class="code" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held.">ensure_invariant</a>(*it, k, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it], <span class="keyword">true</span>);
        }

        <span class="comment">//add new entries for new col k into list</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71" title="Row indices of non-zeros in the new column k.">col_k_nnzs</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71" title="Row indices of non-zeros in the new column k.">col_k_nnzs</a>.end(); it++) {
                <span class="keywordflow">if</span> ((*it != k) &amp;&amp; (*it &lt;= r)) {
                        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it].push_back(k);
                        <a class="code" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held.">ensure_invariant</a>(*it, k, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[*it], <span class="keyword">true</span>);
                }
        }
        
        <span class="comment">//set the kth col</span>
        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[k].swap(s.<a class="code" href="classswap__struct.html#a7a9e67b4e6e1b9d1e6d2aefef3edda71" title="Row indices of non-zeros in the new column k.">col_k_nnzs</a>);
        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[k].swap(s.<a class="code" href="classswap__struct.html#a39ab00a67015a67c375b620f54cc6352" title="Non-zero values in the new column k (order dependent on col_k_nnzs).">col_k</a>);
        
        <span class="comment">//set the rth col</span>
        <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[r].swap(s.<a class="code" href="classswap__struct.html#a8d4e30cd03fc142b81a332db04edc244" title="Row indices of non-zeros in the new column r.">col_r_nnzs</a>);
        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[r].swap(s.<a class="code" href="classswap__struct.html#a3803a938141694098700de00d5cb6a7d" title="Non-zero values in the new column r (order dependent on col_r_nnzs).">col_r</a>);
        
        <span class="comment">//set the kth row and rth row</span>
        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].swap(s.<a class="code" href="classswap__struct.html#a52180e1635646cd4f2dab0209ae62cb9" title="Column indices of non-zeros in the new row k.">row_k</a>);
        <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].swap(s.<a class="code" href="classswap__struct.html#a3b6ad04f7393ddd5c8b130e33208d427" title="Column indices of non-zeros in the new row r.">row_r</a>);

        <span class="comment">//row swaps for first</span>
        std::swap(<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[k], <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[r]);
        <span class="comment">//--------end pivot A---------//</span>
        
        <span class="comment">//----------pivot L ----------//</span>
        s.<a class="code" href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581" title="Clears all swap vectors (swapk, swapr, all_swaps).">swap_clear</a>();

        <span class="comment">// -------------------- (1) for L ------------------------//</span>
        <span class="comment">//push back pointers to L(k, i)</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].begin(); it != L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].end(); it++)
        {
                <span class="keywordflow">for</span> (i = L.<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[*it]; i &lt; (<span class="keywordtype">int</span>) L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it].size(); i++) {
                        <span class="keywordflow">if</span> (L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it][i] == k) {
                                s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9" title="List of indices from row k that will be swapped to row r.">swapr</a>.push_back(L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it].begin() + i);
                                <span class="keywordflow">break</span>;
                        }
                }
        }
        
        <span class="comment">//push back pointers to L(r, i)</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].begin(); it != L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].end(); it++) {
                <span class="keywordflow">for</span> (i = L.<a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>[*it]; i &lt; (<span class="keywordtype">int</span>) L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it].size(); i++) {
                        <span class="keywordflow">if</span> (L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it][i] == r) {                             
                                s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9" title="List of indices from row r that will be swapped to row k.">swapk</a>.push_back(L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it].begin() + i);
                                <span class="keywordflow">break</span>;
                        }
                }
        }
        
        <span class="comment">//swap rows k and r</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9" title="List of indices from row r that will be swapped to row k.">swapk</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a609dd0d32e04b30b0db6830ab56a8de9" title="List of indices from row r that will be swapped to row k.">swapk</a>.end(); it++) {
                **it = k;
        }
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9" title="List of indices from row k that will be swapped to row r.">swapr</a>.begin(); it != s.<a class="code" href="classswap__struct.html#a145f164cc7d5b81b259f0fe558faacf9" title="List of indices from row k that will be swapped to row r.">swapr</a>.end(); it++) {
                **it = r;
        }
        
        <span class="comment">//merge nonzero indices of row r and row k</span>
        s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.assign(L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].begin(), L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r].end());
        <a class="code" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65" title="Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list...">unordered_inplace_union</a>(s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>, L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].begin(), L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].end(), in_set);
        
        <span class="comment">//ensure invariant is held on the columns we just swapped.</span>
        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.begin(); it != s.<a class="code" href="classswap__struct.html#af5461fcf0c0808ef0ef5ac9c6e212839" title="Column indices of all swaps done in swapk and swapr.">all_swaps</a>.end(); it++) {
                L.<a class="code" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held.">ensure_invariant</a>(*it, k, L.<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[*it]);               
        }

        <span class="comment">//row swap on row non-zero indices stored in L.list</span>
        L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[k].swap(L.<a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[r]);

        <span class="comment">//--------end pivot L---------//</span>
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_ad2c9a672941d6b47d3c60f631d21078c_cgraph.png" border="0" usemap="#classlilc__matrix_ad2c9a672941d6b47d3c60f631d21078c_cgraph" alt=""/></div>
<map name="classlilc__matrix_ad2c9a672941d6b47d3c60f631d21078c_cgraph" id="classlilc__matrix_ad2c9a672941d6b47d3c60f631d21078c_cgraph">
<area shape="rect" id="node3" href="classswap__struct.html#ad97200ee23cd1f70668d6b4462228343" title="Clears all col vectors (col_k, col_r, col_k_nnzs, col_r_nnzs)." alt="" coords="191,5,351,32"/><area shape="rect" id="node5" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held." alt="" coords="173,56,368,83"/><area shape="rect" id="node7" href="classswap__struct.html#a9727bf8ea70308977661235c59e3b8da" title="Clears all row vectors (row_k, row_r)." alt="" coords="188,107,353,133"/><area shape="rect" id="node9" href="lilc__matrix__ildl__helpers_8h.html#ac6f821ca233295dd508731797ed4d954" title="safe_swap" alt="" coords="225,157,316,184"/><area shape="rect" id="node11" href="classswap__struct.html#ac67fad73735b183c372ef63b4a9cd581" title="Clears all swap vectors (swapk, swapr, all_swaps)." alt="" coords="183,208,358,235"/><area shape="rect" id="node13" href="lilc__matrix__ildl__helpers_8h.html#ae20b651091f6b6f887a8c4a41ac32e65" title="Performs an inplace union of two unsorted lists (a and b), removing duplicates in the final list..." alt="" coords="179,259,362,285"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aca815e0ac073abb1e6ef888b09f9e795"></a><!-- doxytag: member="lilc_matrix::resize" ref="aca815e0ac073abb1e6ef888b09f9e795" args="(int n_rows, int n_cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes the matrix. For use in preallocating space before factorization begins. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n_rows</td><td>the number of rows in the resized matrix. </td></tr>
    <tr><td class="paramname">n_cols</td><td>the number of cols in the resized matrix. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">        {
                <a class="code" href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9" title="Number of rows in the matrix.">m_n_rows</a> = <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>;
                <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a> = <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>;
                
                <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);
                <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);
                
                <a class="code" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3" title="On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i...">first</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>, 1);
                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);
                
                <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>.resize(<a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>);
        }
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph.png" border="0" usemap="#classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph" alt=""/></div>
<map name="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph" id="classlilc__matrix_aca815e0ac073abb1e6ef888b09f9e795_cgraph">
<area shape="rect" id="node3" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d" title="lil_sparse_matrix::n_cols" alt="" coords="185,5,359,32"/><area shape="rect" id="node5" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0" title="lil_sparse_matrix::n_rows" alt="" coords="182,56,362,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aad2918af411cbef86995537f646fc2ae"></a><!-- doxytag: member="lilc_matrix::save" ref="aad2918af411cbef86995537f646fc2ae" args="(std::string filename, bool sym)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::save </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sym</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Saves a matrix in matrix market format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be saved. All matrices saved are in matrix market format (.mtx). </td></tr>
    <tr><td class="paramname">sym</td><td>flags whether the matrix is symmetric or not. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">{
        std::ofstream out(filename.c_str(), std::ios::out | std::ios::binary);
        <span class="keywordflow">if</span>(!out)
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

        out.flags(std::ios_base::scientific);
        out.precision(16);
        std::string header; 
        <a class="code" href="lilc__matrix__save_8h.html#abea199c89e226136ca0039f1dfcd133f">put_header</a>(header, sym); 

        out &lt;&lt; header &lt;&lt; std::endl; 
        out &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(); i++) {
                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i].size(); j++) {
                        out &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i][j]+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i][j] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
                }
        }
        
        out.close();
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_aad2918af411cbef86995537f646fc2ae_cgraph.png" border="0" usemap="#classlilc__matrix_aad2918af411cbef86995537f646fc2ae_cgraph" alt=""/></div>
<map name="classlilc__matrix_aad2918af411cbef86995537f646fc2ae_cgraph" id="classlilc__matrix_aad2918af411cbef86995537f646fc2ae_cgraph">
<area shape="rect" id="node3" href="lilc__matrix__save_8h.html#abea199c89e226136ca0039f1dfcd133f" title="put_header" alt="" coords="174,5,269,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a37fc8dcc40799dfde0decaaf8bd74b51"></a><!-- doxytag: member="lilc_matrix::sym_equil" ref="a37fc8dcc40799dfde0decaaf8bd74b51" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_equil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A, where S is a diagonal scaling matrix. </p>
<p>This algorithm is based on the one outlined in "Equilibration of Symmetric Matrices in the Max-Norm" by Bunch (1971). </p>
<div class="fragment"><pre class="fragment">                                       {

        <span class="comment">//find termination points for loops with binary search later.</span>
        <span class="keywordtype">int</span> i, ncols = <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>();
        std::pair&lt;idx_it, elt_it&gt; elem_its;
        <span class="keywordflow">for</span> (i = 0; i &lt; ncols; i++) {
                <span class="comment">//assumes diag elem is always in 0th pos. if possible.</span>
                <span class="keywordflow">if</span> (!<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i].empty() &amp;&amp; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i][0] == i)
                <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i] = sqrt(abs(<a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i][0]));
                
                <span class="comment">//assumes indices are ordered. since this procedure is run</span>
                <span class="comment">//before factorization pivots matrix, this is a fair assumption</span>
                <span class="comment">//for most matrix market matrices.</span>
                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[i].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[i].end(); it++) {
                        <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i] = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index.">std::max</a>(<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i], abs(<a class="code" href="classlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753" title="Finds the (i,j)th coefficient of the matrix.">coeff</a>(i, *it)));
                }
                
                <span class="keywordflow">if</span> (abs(<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i]) &gt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) { 
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[i].begin(); it != <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[i].end(); it++) {
                                <a class="code" href="classlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd" title="Finds the index/value pointers to (i,j)th coefficient of the matrix.">coeffRef</a>(i, *it, elem_its);
                                
                                <span class="comment">//can use bin. search on coeff since no reordering is done yet.</span>
                                *(elem_its.second) /= <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i]; 
                        }

                        <span class="keywordflow">if</span> (!<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i].empty() &amp;&amp; (<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i][0] == i) ) 
                        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i][0] /= <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i];
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i].begin(); it != <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i].end(); it++) {
                                *it /= <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i];
                        }
                } 
        }
        
        <span class="keywordflow">for</span> (i = 0; i &lt; ncols; i++) {
                <span class="keywordflow">if</span> (abs(<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i]) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) {
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i].begin(); it != <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i].end(); it++) {
                                <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i] = <a class="code" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index.">std::max</a>(<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i], abs(*it));
                        }

                        <span class="keywordflow">if</span> (abs(<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i]) &lt; <a class="code" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56" title="Machine epsilon for el_type.">eps</a>) {
                                std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: Matrix has a null column/row.&quot;</span> &lt;&lt; std::endl;
                                <span class="keywordflow">return</span>;
                        }
                        
                        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i].begin(); it != <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i].end(); it++) {
                                *it /= <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i];
                        }
                }
        }
        
        <span class="keywordflow">for</span> (i = 0; i &lt; ncols; i++) {
                <a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i]  = 1.0/<a class="code" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596" title="A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the sym_equil() function, after which SAS will be stored in place of A.">S</a>[i];
        }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classlilc__matrix_a37fc8dcc40799dfde0decaaf8bd74b51_cgraph.png" border="0" usemap="#classlilc__matrix_a37fc8dcc40799dfde0decaaf8bd74b51_cgraph" alt=""/></div>
<map name="classlilc__matrix_a37fc8dcc40799dfde0decaaf8bd74b51_cgraph" id="classlilc__matrix_a37fc8dcc40799dfde0decaaf8bd74b51_cgraph">
<area shape="rect" id="node3" href="lilc__matrix__ildl__helpers_8h.html#a1c1c106c91e87594d7cfbcdb55224d5a" title="Computes the maximum (in absolute value) element of v(curr_nnzs) and it&#39;s index." alt="" coords="205,5,253,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af72f55f6880cef04205eb3df7018bce9"></a><!-- doxytag: member="lilc_matrix::sym_perm" ref="af72f55f6880cef04205eb3df7018bce9" args="(vector&lt; int &gt; &amp;perm)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_perm </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a permutation vector perm, A is permuted to P'AP, where P is the permutation matrix associated with perm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>the permutation vector. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                                          {
        vector&lt;idx_vector_type&gt; m_idx_new(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>);
        vector&lt;elt_vector_type&gt; m_x_new(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>);
        
        <span class="keywordtype">int</span> i, j, pi, pj;
        el_type px;
        vector&lt;int&gt; pinv(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>);
        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>; i++) {
                pinv[perm[i]] = i;
                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[i].clear();
        }
        
        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>; i++) { <span class="comment">//no need to use function call n_cols() every iter</span>
                pj = pinv[i];
                
                <span class="keywordflow">for</span> (j = 0; j &lt; (int) <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i].size(); j++) {
                        pi = pinv[<a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i][j]];
                        px = <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i][j];
                        
                        <span class="keywordflow">if</span> (pi &lt; pj) {
                                m_idx_new[ pi ].push_back(pj);
                                m_x_new[ pi ].push_back(px);
                                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[pj].push_back(pi);
                                
                        } <span class="keywordflow">else</span> {
                                m_idx_new[ pj ].push_back(pi);
                                m_x_new[ pj ].push_back(px);
                                
                                <span class="keywordflow">if</span> (pi != pj)
                                <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[pi].push_back(pj);
                                
                        }
                }
        }
        
        m_idx.swap(m_idx_new);
        <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>.swap(m_x_new);
        
        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>; i++) {
                <a class="code" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held.">ensure_invariant</a>(i, i, m_idx[i]);
                <a class="code" href="classlilc__matrix.html#aea44b3b7358782ffe30f703b3f738aa2" title="Ensures two the invariants observed by A.first and A.list are held.">ensure_invariant</a>(i, i, <a class="code" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81" title="A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may sw...">list</a>[i], <span class="keyword">true</span>);
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab34914d2b48a5bf14e7ef22e89d2f2e7"></a><!-- doxytag: member="lilc_matrix::sym_rcm" ref="ab34914d2b48a5bf14e7ef22e89d2f2e7" args="(vector&lt; int &gt; &amp;perm)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_rcm </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a Reverse Cuthill-McKee ordering of the matrix A (stored in perm). </p>
<p>The implementation is based on the general algorithm outlined in A detailed description of this function as well as all its subfunctions can be found in "Computer Solution of Large Sparse Positive Definite Systems" by George and Liu (1981). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The original permutation of A (usually initialized with 0 ... n-1). </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">                                                             {
        <span class="keywordtype">int</span> i, s;
        vector&lt;bool&gt; visited(<a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>, <span class="keyword">false</span>);
        vector&lt;int&gt; lvl_set;
        <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a>; i++) {
                <span class="keywordflow">if</span> (visited[i]) <span class="keywordflow">continue</span>;
                
                lvl_set.clear();
                s = i;
                <a class="code" href="classlilc__matrix.html#a46161695c5bfb0f43a7dedb9b9146fef" title="Returns a pseudo-peripheral root of A. This is essentially many chained breadth-first searchs across ...">find_root</a>(s);
                lvl_set.push_back(s);
                perm.push_back(s);
                
                <a class="code" href="structby__degree.html" title="Functor for comparing elements by degree (in increasing order) instead of by index.">by_degree&lt;el_type&gt;</a> sorter(<span class="keyword">this</span>);
                
                visited[s] = <span class="keyword">true</span>;
                <span class="keywordflow">while</span> (<a class="code" href="classlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5" title="Returns the next level set given the current level set of A. This is essentially all neighbours of th...">find_level_set</a>(lvl_set, visited)) {
                        sort(lvl_set.begin(), lvl_set.end(), sorter);
                        perm.insert( perm.end(), lvl_set.begin(), lvl_set.end() );      
                }
        }
        
        reverse(perm.begin(), perm.end());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a60c5a4a0ec9a49d43be087b6d67f4df2"></a><!-- doxytag: member="lilc_matrix::to_string" ref="a60c5a4a0ec9a49d43be087b6d67f4df2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a string representation of A, with each column and its corresponding indices &amp; non-zero values printed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string representation of this matrix. </dd></dl>

<p>Implements <a class="el" href="classlil__sparse__matrix.html#a5c2c43867660473176de5c73ebdac7be">lil_sparse_matrix&lt; el_type &gt;</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::ostringstream os;
  os &lt;&lt; <span class="stringliteral">&quot;List of Lists Matrix (&quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9" title="Number of rows in the matrix.">m_n_rows</a> &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a" title="Number of cols in the matrix.">m_n_cols</a> &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
  
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>(); i++) {
    os &lt;&lt; <span class="stringliteral">&quot;Column &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;
    os &lt;&lt; <span class="stringliteral">&quot;Row      Indices = &quot;</span>  &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6" title="The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R...">m_idx</a>[i] &lt;&lt; std::endl;
    os &lt;&lt; <span class="stringliteral">&quot;Non-zero Values  = &quot;</span>  &lt;&lt; <a class="code" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de" title="The values of the nonzeros in the matrix.">m_x</a>[i]       &lt;&lt; std::endl;
    os &lt;&lt; std::endl;
  }
  
  <span class="keywordflow">return</span> os.str();
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a12026d9abf82ced3faf37d6b8e4b95d3"></a><!-- doxytag: member="lilc_matrix::first" ref="a12026d9abf82ced3faf37d6b8e4b95d3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#a12026d9abf82ced3faf37d6b8e4b95d3">first</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>On iteration k, first[i] gives the number of non-zero elements on col (or row) i of A before A(i, k). </p>

</div>
</div>
<a class="anchor" id="ad942a0e5503a2b4327a12287432fca81"></a><!-- doxytag: member="lilc_matrix::list" ref="ad942a0e5503a2b4327a12287432fca81" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may swap between two rows, we require linked lists for each row of A. </p>

</div>
</div>
<a class="anchor" id="afc4659265addfeab376ffaa8f54ed596"></a><!-- doxytag: member="lilc_matrix::S" ref="afc4659265addfeab376ffaa8f54ed596" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt;el_type&gt; <a class="el" href="classlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::<a class="el" href="classlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the <a class="el" href="classlilc__matrix.html#a37fc8dcc40799dfde0decaaf8bd74b51" title="The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A...">sym_equil()</a> function, after which SAS will be stored in place of A. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/<a class="el" href="lilc__matrix__declarations_8h_source.html">lilc_matrix_declarations.h</a></li>
<li>source/<a class="el" href="lilc__matrix__find__level__set_8h_source.html">lilc_matrix_find_level_set.h</a></li>
<li>source/<a class="el" href="lilc__matrix__find__root_8h_source.html">lilc_matrix_find_root.h</a></li>
<li>source/<a class="el" href="lilc__matrix__ildl_8h_source.html">lilc_matrix_ildl.h</a></li>
<li>source/<a class="el" href="lilc__matrix__load_8h_source.html">lilc_matrix_load.h</a></li>
<li>source/<a class="el" href="lilc__matrix__pivot_8h_source.html">lilc_matrix_pivot.h</a></li>
<li>source/<a class="el" href="lilc__matrix__save_8h_source.html">lilc_matrix_save.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__equil_8h_source.html">lilc_matrix_sym_equil.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__perm_8h_source.html">lilc_matrix_sym_perm.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__rcm_8h_source.html">lilc_matrix_sym_rcm.h</a></li>
<li>source/<a class="el" href="lilc__matrix__to__string_8h_source.html">lilc_matrix_to_string.h</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Aug 29 2012 02:59:54 for matrix-factor by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
