#ifndef _CSC_MATRIX_ILDL_H_
#define _CSC_MATRIX_ILDL_H_

#include <algorithm>

template <class idx_type, class el_type>
inline double norm(std::vector<el_type>& v) { 
    //optimize later
    double res = 0;
    //may want to use abs later if want to deal with complex
    for (idx_type i = 0; i < v.size(); i++) res += v[i]*v[i];  
    return res;
}

//optimize later.
template <class idx_type>
struct by_value {
    std::vector<idx_type>& v; 
    by_value(std::vector<idx_type>& vec) : v(vec) {}
    bool operator()(idx_type const &a, idx_type const &b) const { 
        return v[a] > v[b];
    }
};

template <class idx_type, class el_type>
inline void drop_tol(std::vector<el_type>& v, std::vector<idx_type>& nnzs, int lfil, double tol) { 
    //optimize later
    el_type tolerance = tol*norm<idx_type, el_type>(v);
    for (idx_type i = 0; i < v.size(); i++) 
        if (v[i] < tolerance) v[i] = 0;
        
    //do lfil later. approach: use merge while doing delayed updates to obtain list of non zeros. sort nnzs by value. only assign lfil largest to new vector
    by_value<idx_type> sorter(nnzs);
    std::sort(nnzs.begin(), nnzs.end(), sorter);
    
    nnzs.resize(lfil);
    std::sort(nnzs.begin(), nnzs.end());
}

template <class idx_type, class InputIterator>
inline void inplace_union(std::vector<idx_type>& a, InputIterator b_start, InputIterator b_end)
{
    int mid = a.size(); //Store the end of first sorted range

    //First copy the second sorted range into the destination vector
    std::copy(b_start, b_end, std::back_inserter(a));

    //Then perform the in place merge on the two sub-sorted ranges.
    std::inplace_merge(a.begin(), a.begin() + mid, a.end());

    //Remove duplicate elements from the sorted vector
    a.erase(std::unique(a.begin(), a.end()), a.end());
}


template <class idx_type, class el_type>
void csc_matrix<idx_type, el_type> :: ildl(csc_matrix<idx_type, el_type>& L, elt_vector_type& D, int lfil, double tol)
{
    int count = 0;
	std::vector<el_type> work(n_cols());
	std::vector<idx_type> nnzs;
	nnzs.reserve(n_cols());
	
	L.resize(n_rows(), n_cols(), lfil*n_cols());
	D.resize(n_cols());
	
	//set d_k = a_kk switch to binary search later
	for (idx_type i = 0; i < n_cols(); i++) {
		//std::cout << i << std::endl;
		for (idx_type j = m_col_idx[i]; j < m_col_idx[i+1]; j++) {
			//std::cout << '\t' << m_row_idx[j] << std::endl;
			if (m_row_idx[j] == i) {
				D[i] = m_x[j]; 
				break;
			}
		}
	}
	
	for (idx_type k = 0; k < n_cols(); k++) {
	
	    //zero out work vector (opt. later)
	    std::fill (work.begin(), work.end(), 0);
	    
	    //the +1 is to avoid assigning diagonal element as nonzero since its stored in D already
	    nnzs.assign (m_row_idx.begin() + m_col_idx[k] + 1, m_row_idx.begin() + m_col_idx[k+1]);
	    
	    //needs optimization for sparse vector add later (maybe turn work vector into sparse vector,
	    //use STL merge on row indices).
	    for (idx_type j = m_col_idx[k]; j < m_col_idx[k+1]; j++) {	        
		    work[m_row_idx[j]] = m_x[j];
		}
		
		for (idx_type i = 0; i < k; i++) {
		    //assumes matrix is symmetric with only lower triangular part stored. may want to change later.
		    for (idx_type j = m_col_idx[i]; j < m_col_idx[i+1]; j++) {	        
		        work[m_row_idx[j]] -= L.coeff(k, i) * D[i] * m_x[j];
		    }
		    
		    //find exactly where to merge with binary search.
		    inplace_union(nnzs, m_row_idx.begin() + m_col_idx[i] + 1, m_row_idx.begin() + m_col_idx[i+1]);
		}
		
		for (int i = 0; i < nnzs.size(); i++) //<--- drop the elements that are less than k!
		
		drop_tol(work, nnzs, lfil, tol);
		
		std::cout << work << std::endl;
		std::cout << nnzs << std::endl;
		//get 1s on the diagonal
//		L.m_row_idx[count] = k;
//		L.m_x[count] = 1;
//		count++;
//		
//		for (idx_type i = 0; i < nnzs.size(); i++) {
//		    L.m_row_idx[count] = nnzs[i];
//		    L.m_x[count] = work[nnzs[i]]/D[k];
//		    count++;
//		}
//		
//		L.m_col_idx[k+1] = count;
		
	}
	
	std::cout << D << std::endl;
}

#endif 
